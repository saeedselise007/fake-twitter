/**
 * @fileoverview added by tsickle
 * Generated from: lib/transloco.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Inject, Injectable, Optional } from '@angular/core';
import { BehaviorSubject, combineLatest, EMPTY, forkJoin, from, of, Subject } from 'rxjs';
import { catchError, map, retry, shareReplay, switchMap, tap } from 'rxjs/operators';
import { DefaultLoader, TRANSLOCO_LOADER } from './transloco.loader';
import { TRANSLOCO_TRANSPILER } from './transloco.transpiler';
import { flatten, isEmpty, isNil, isScopeObject, isString, size, toCamelCase, unflatten } from './helpers';
import { defaultConfig, TRANSLOCO_CONFIG } from './transloco.config';
import { TRANSLOCO_MISSING_HANDLER } from './transloco-missing-handler';
import { TRANSLOCO_INTERCEPTOR } from './transloco.interceptor';
import { TRANSLOCO_FALLBACK_STRATEGY } from './transloco-fallback-strategy';
import { mergeConfig } from './merge-config';
import { getEventPayload, getLangFromScope, getScopeFromLang, resolveInlineLoader } from './shared';
import { getFallbacksLoaders } from './get-fallbacks-loaders';
import { resolveLoader } from './resolve-loader';
import * as i0 from "@angular/core";
import * as i1 from "./transloco.loader";
import * as i2 from "./transloco.transpiler";
import * as i3 from "./transloco-missing-handler";
import * as i4 from "./transloco.interceptor";
import * as i5 from "./transloco.config";
import * as i6 from "./transloco-fallback-strategy";
/** @type {?} */
var service;
/**
 * @template T
 * @param {?} key
 * @param {?=} params
 * @param {?=} lang
 * @return {?}
 */
export function translate(key, params, lang) {
    if (params === void 0) { params = {}; }
    return service.translate(key, params, lang);
}
var TranslocoService = /** @class */ (function () {
    function TranslocoService(loader, parser, missingHandler, interceptor, userConfig, fallbackStrategy) {
        var _this = this;
        this.loader = loader;
        this.parser = parser;
        this.missingHandler = missingHandler;
        this.interceptor = interceptor;
        this.userConfig = userConfig;
        this.fallbackStrategy = fallbackStrategy;
        this.translations = new Map();
        this.cache = new Map();
        this.firstFallbackLang = null;
        this.availableLangs = [];
        this.isResolvedMissingOnce = false;
        this.events = new Subject();
        this.events$ = this.events.asObservable();
        this.failedLangs = new Set();
        if (!this.loader) {
            this.loader = new DefaultLoader(this.translations);
        }
        service = this;
        this.mergedConfig = mergeConfig(defaultConfig, userConfig);
        this.setAvailableLangs(this.mergedConfig.availableLangs);
        this.setFallbackLangForMissingTranslation(this.mergedConfig);
        this.setDefaultLang(this.mergedConfig.defaultLang);
        this.lang = new BehaviorSubject(this.getDefaultLang());
        // Don't use distinctUntilChanged as we need the ability to update
        // the value when using setTranslation or setTranslationKeys
        this.langChanges$ = this.lang.asObservable();
        /**
         * When we have a failure, we want to define the next language that succeeded as the active
         */
        this.subscription = this.events$.subscribe((/**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            if (e.type === 'translationLoadSuccess' && e.wasFailure) {
                // Handle scoped lang
                /** @type {?} */
                var lang = getLangFromScope(e.payload.lang);
                _this.setActiveLang(lang);
            }
        }));
    }
    Object.defineProperty(TranslocoService.prototype, "config", {
        get: /**
         * @return {?}
         */
        function () {
            return this.mergedConfig;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    TranslocoService.prototype.getDefaultLang = /**
     * @return {?}
     */
    function () {
        return this.defaultLang;
    };
    /**
     * @param {?} lang
     * @return {?}
     */
    TranslocoService.prototype.setDefaultLang = /**
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        this.defaultLang = lang;
    };
    /**
     * @return {?}
     */
    TranslocoService.prototype.getActiveLang = /**
     * @return {?}
     */
    function () {
        return this.lang.getValue();
    };
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} lang
     * @return {THIS}
     */
    TranslocoService.prototype.setActiveLang = /**
     * @template THIS
     * @this {THIS}
     * @param {?} lang
     * @return {THIS}
     */
    function (lang) {
        (/** @type {?} */ (this)).lang.next(lang);
        (/** @type {?} */ (this)).parser.onLangChanged && (/** @type {?} */ (this)).parser.onLangChanged(lang);
        return (/** @type {?} */ (this));
    };
    /**
     * @param {?} langs
     * @return {?}
     */
    TranslocoService.prototype.setAvailableLangs = /**
     * @param {?} langs
     * @return {?}
     */
    function (langs) {
        this.availableLangs = langs;
    };
    /**
     * Gets the available languages.
     *
     * @returns
     * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`
     * depending on how the available languages are set in your module.
     */
    /**
     * Gets the available languages.
     *
     * @return {?}
     * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`
     * depending on how the available languages are set in your module.
     */
    TranslocoService.prototype.getAvailableLangs = /**
     * Gets the available languages.
     *
     * @return {?}
     * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`
     * depending on how the available languages are set in your module.
     */
    function () {
        return this.availableLangs;
    };
    /**
     * @param {?} path
     * @param {?=} options
     * @return {?}
     */
    TranslocoService.prototype.load = /**
     * @param {?} path
     * @param {?=} options
     * @return {?}
     */
    function (path, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (this.cache.has(path) === false) {
            /** @type {?} */
            var loadTranslation = void 0;
            /** @type {?} */
            var isScope = this._isLangScoped(path);
            /** @type {?} */
            var scope = isScope ? getScopeFromLang(path) : null;
            if (this.useFallbackTranslation(path)) {
                // if the path is scope the fallback should be `scope/fallbackLang`;
                /** @type {?} */
                var fallback = isScope ? scope + "/" + this.firstFallbackLang : this.firstFallbackLang;
                /** @type {?} */
                var loaders = getFallbacksLoaders(path, fallback, this.loader, options.inlineLoader, { scope: scope });
                loadTranslation = forkJoin(loaders);
            }
            else {
                /** @type {?} */
                var loader = resolveLoader(path, this.loader, options.inlineLoader, { scope: scope });
                loadTranslation = from(loader);
            }
            /** @type {?} */
            var load$ = loadTranslation.pipe(retry(this.config.failedRetries), tap((/**
             * @param {?} translation
             * @return {?}
             */
            function (translation) {
                if (Array.isArray(translation)) {
                    translation.forEach((/**
                     * @param {?} t
                     * @return {?}
                     */
                    function (t) {
                        _this.handleSuccess(t.lang, t.translation);
                        // Save the fallback in cache so we'll not create a redundant request
                        if (t.lang !== path) {
                            _this.cache.set(t.lang, of({}));
                        }
                    }));
                    return;
                }
                _this.handleSuccess(path, translation);
            })), catchError((/**
             * @return {?}
             */
            function () { return _this.handleFailure(path, options); })), shareReplay(1));
            this.cache.set(path, load$);
        }
        return this.cache.get(path);
    };
    /**
     * Gets the instant translated value of a key
     *
     * @example
     *
     * translate<string>('hello')
     * translate('hello', { value: 'value' })
     * translate<string[]>(['hello', 'key'])
     * translate('hello', { }, 'en')
     * translate('scope.someKey', { }, 'en')
     */
    /**
     * Gets the instant translated value of a key
     *
     * \@example
     *
     * translate<string>('hello')
     * translate('hello', { value: 'value' })
     * translate<string[]>(['hello', 'key'])
     * translate('hello', { }, 'en')
     * translate('scope.someKey', { }, 'en')
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @return {?}
     */
    TranslocoService.prototype.translate = /**
     * Gets the instant translated value of a key
     *
     * \@example
     *
     * translate<string>('hello')
     * translate('hello', { value: 'value' })
     * translate<string[]>(['hello', 'key'])
     * translate('hello', { }, 'en')
     * translate('scope.someKey', { }, 'en')
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @return {?}
     */
    function (key, params, lang) {
        var _this = this;
        if (params === void 0) { params = {}; }
        if (lang === void 0) { lang = this.getActiveLang(); }
        if (!key)
            return (/** @type {?} */ (key));
        var _a = this.resolveLangAndScope(lang), scope = _a.scope, resolveLang = _a.resolveLang;
        if (Array.isArray(key)) {
            return (/** @type {?} */ (key.map((/**
             * @param {?} k
             * @return {?}
             */
            function (k) { return _this.translate(scope ? scope + "." + k : k, params, resolveLang); }))));
        }
        key = scope ? scope + "." + key : key;
        /** @type {?} */
        var translation = this.getTranslation(resolveLang);
        /** @type {?} */
        var value = translation[key];
        if (!value) {
            return this._handleMissingKey(key, value, params);
        }
        return this.parser.transpile(value, params, translation);
    };
    /**
     * Gets the translated value of a key as observable
     *
     * @example
     *
     * selectTranslate<string>('hello').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)
     *
     */
    /**
     * Gets the translated value of a key as observable
     *
     * \@example
     *
     * selectTranslate<string>('hello').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)
     *
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @param {?=} _isObject
     * @return {?}
     */
    TranslocoService.prototype.selectTranslate = /**
     * Gets the translated value of a key as observable
     *
     * \@example
     *
     * selectTranslate<string>('hello').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)
     *
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @param {?=} _isObject
     * @return {?}
     */
    function (key, params, lang, _isObject) {
        var _this = this;
        if (_isObject === void 0) { _isObject = false; }
        /** @type {?} */
        var inlineLoader = null;
        /** @type {?} */
        var load = (/**
         * @param {?} lang
         * @param {?=} options
         * @return {?}
         */
        function (lang, options) {
            return _this.load(lang, options).pipe(map((/**
             * @return {?}
             */
            function () { return (_isObject ? _this.translateObject(key, params, lang) : _this.translate(key, params, lang)); })));
        });
        if (isNil(lang)) {
            return this.langChanges$.pipe(switchMap((/**
             * @param {?} lang
             * @return {?}
             */
            function (lang) { return load(lang); })));
        }
        if (isScopeObject(lang)) {
            // it's a scope object.
            /** @type {?} */
            var providerScope = (/** @type {?} */ (lang));
            lang = providerScope.scope;
            inlineLoader = resolveInlineLoader(providerScope, providerScope.scope);
        }
        lang = (/** @type {?} */ (lang));
        if (this.isLang(lang) || this.isScopeWithLang(lang)) {
            return load(lang);
        }
        // it's a scope
        /** @type {?} */
        var scope = lang;
        return this.langChanges$.pipe(switchMap((/**
         * @param {?} lang
         * @return {?}
         */
        function (lang) { return load(scope + "/" + lang, { inlineLoader: inlineLoader }); })));
    };
    /**
     * Whether the scope with lang
     *
     * @example
     *
     * todos/en => true
     * todos => false
     */
    /**
     * Whether the scope with lang
     *
     * \@example
     *
     * todos/en => true
     * todos => false
     * @private
     * @param {?} lang
     * @return {?}
     */
    TranslocoService.prototype.isScopeWithLang = /**
     * Whether the scope with lang
     *
     * \@example
     *
     * todos/en => true
     * todos => false
     * @private
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        return this.isLang(getLangFromScope(lang));
    };
    /**
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @return {?}
     */
    TranslocoService.prototype.translateObject = /**
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @return {?}
     */
    function (key, params, lang) {
        var _this = this;
        if (lang === void 0) { lang = this.getActiveLang(); }
        var e_1, _a;
        if (isString(key) || Array.isArray(key)) {
            if (Array.isArray(key)) {
                return (/** @type {?} */ (key.map((/**
                 * @param {?} k
                 * @return {?}
                 */
                function (k) { return _this.translateObject(scope_1 ? scope_1 + "." + k : k, params, resolveLang_1); }))));
            }
            var _b = this.resolveLangAndScope(lang), resolveLang_1 = _b.resolveLang, scope_1 = _b.scope;
            /** @type {?} */
            var translation = this.getTranslation(resolveLang_1);
            key = scope_1 ? scope_1 + "." + key : key;
            /** @type {?} */
            var value = unflatten(this.getObjectByKey(translation, key));
            /* If an empty object was returned we want to try and translate the key as a string and not an object */
            return isEmpty(value) ? this.translate(key, params, lang) : this.parser.transpile(value, params, translation);
        }
        /** @type {?} */
        var translations = [];
        try {
            for (var _c = tslib_1.__values(this.getEntries(key)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var _e = tslib_1.__read(_d.value, 2), _key = _e[0], _params = _e[1];
                translations.push(this.translateObject(_key, _params, lang));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return translations;
    };
    /**
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @return {?}
     */
    TranslocoService.prototype.selectTranslateObject = /**
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @return {?}
     */
    function (key, params, lang) {
        var _this = this;
        if (isString(key) || Array.isArray(key)) {
            return this.selectTranslate(key, params, lang, true);
        }
        var _a = tslib_1.__read(this.getEntries(key)), _b = tslib_1.__read(_a[0], 2), firstKey = _b[0], firstParams = _b[1], rest = _a.slice(1);
        /* In order to avoid subscribing multiple times to the load language event by calling selectTranslateObject for each pair,
         * we listen to when the first key has been translated (the language is loaded) and translate the rest synchronously */
        return this.selectTranslateObject(firstKey, firstParams, lang).pipe(map((/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var e_2, _a;
            /** @type {?} */
            var translations = [value];
            try {
                for (var rest_1 = tslib_1.__values(rest), rest_1_1 = rest_1.next(); !rest_1_1.done; rest_1_1 = rest_1.next()) {
                    var _b = tslib_1.__read(rest_1_1.value, 2), _key = _b[0], _params = _b[1];
                    translations.push(_this.translateObject(_key, _params, lang));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (rest_1_1 && !rest_1_1.done && (_a = rest_1.return)) _a.call(rest_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return translations;
        })));
    };
    /**
     * @param {?=} langOrScope
     * @return {?}
     */
    TranslocoService.prototype.getTranslation = /**
     * @param {?=} langOrScope
     * @return {?}
     */
    function (langOrScope) {
        if (langOrScope) {
            if (this.isLang(langOrScope)) {
                return this.translations.get(langOrScope) || {};
            }
            else {
                // This is a scope, build the scope value from the translation object
                var _a = this.resolveLangAndScope(langOrScope), scope = _a.scope, resolveLang = _a.resolveLang;
                /** @type {?} */
                var translation = this.translations.get(resolveLang) || {};
                return this.getObjectByKey(translation, scope);
            }
        }
        return this.translations;
    };
    /**
     * Gets an object of translations for a given language
     *
     * @example
     *
     * selectTranslation().subscribe() - will return the current lang translation
     * selectTranslation('es').subscribe()
     * selectTranslation('admin-page').subscribe() - will return the current lang scope translation
     * selectTranslation('admin-page/es').subscribe()
     */
    /**
     * Gets an object of translations for a given language
     *
     * \@example
     *
     * selectTranslation().subscribe() - will return the current lang translation
     * selectTranslation('es').subscribe()
     * selectTranslation('admin-page').subscribe() - will return the current lang scope translation
     * selectTranslation('admin-page/es').subscribe()
     * @param {?=} lang
     * @return {?}
     */
    TranslocoService.prototype.selectTranslation = /**
     * Gets an object of translations for a given language
     *
     * \@example
     *
     * selectTranslation().subscribe() - will return the current lang translation
     * selectTranslation('es').subscribe()
     * selectTranslation('admin-page').subscribe() - will return the current lang scope translation
     * selectTranslation('admin-page/es').subscribe()
     * @param {?=} lang
     * @return {?}
     */
    function (lang) {
        var _this = this;
        /** @type {?} */
        var language$ = this.langChanges$;
        if (lang) {
            /** @type {?} */
            var scopeLangSpecified = getLangFromScope(lang) !== lang;
            if (this.isLang(lang) || scopeLangSpecified) {
                language$ = of(lang);
            }
            else {
                language$ = this.langChanges$.pipe(map((/**
                 * @param {?} currentLang
                 * @return {?}
                 */
                function (currentLang) { return lang + "/" + currentLang; })));
            }
        }
        return language$.pipe(switchMap((/**
         * @param {?} language
         * @return {?}
         */
        function (language) { return _this.load(language).pipe(map((/**
         * @return {?}
         */
        function () { return _this.getTranslation(language); }))); })));
    };
    /**
     * Sets or merge a given translation object to current lang
     *
     * @example
     *
     * setTranslation({ ... })
     * setTranslation({ ... }, 'en')
     * setTranslation({ ... }, 'es', { merge: false } )
     * setTranslation({ ... }, 'todos/en', { merge: false } )
     */
    /**
     * Sets or merge a given translation object to current lang
     *
     * \@example
     *
     * setTranslation({ ... })
     * setTranslation({ ... }, 'en')
     * setTranslation({ ... }, 'es', { merge: false } )
     * setTranslation({ ... }, 'todos/en', { merge: false } )
     * @param {?} translation
     * @param {?=} lang
     * @param {?=} options
     * @return {?}
     */
    TranslocoService.prototype.setTranslation = /**
     * Sets or merge a given translation object to current lang
     *
     * \@example
     *
     * setTranslation({ ... })
     * setTranslation({ ... }, 'en')
     * setTranslation({ ... }, 'es', { merge: false } )
     * setTranslation({ ... }, 'todos/en', { merge: false } )
     * @param {?} translation
     * @param {?=} lang
     * @param {?=} options
     * @return {?}
     */
    function (translation, lang, options) {
        if (lang === void 0) { lang = this.getActiveLang(); }
        if (options === void 0) { options = {}; }
        var _a;
        /** @type {?} */
        var defaults = { merge: true, emitChange: true };
        /** @type {?} */
        var mergedOptions = tslib_1.__assign({}, defaults, options);
        /** @type {?} */
        var scope = getScopeFromLang(lang);
        /**
         * If this isn't a scope we use the whole translation as is
         * otherwise we need to flat the scope and use it
         * @type {?}
         */
        var flattenScopeOrTranslation = translation;
        // Merged the scoped language into the active language
        if (scope) {
            /** @type {?} */
            var key = this.getMappedScope(scope);
            flattenScopeOrTranslation = flatten((_a = {}, _a[key] = translation, _a));
        }
        /** @type {?} */
        var currentLang = scope ? getLangFromScope(lang) : lang;
        /** @type {?} */
        var mergedTranslation = tslib_1.__assign({}, (mergedOptions.merge && this.getTranslation(currentLang)), flattenScopeOrTranslation);
        /** @type {?} */
        var flattenTranslation = this.mergedConfig.flatten.aot ? mergedTranslation : flatten(mergedTranslation);
        /** @type {?} */
        var withHook = this.interceptor.preSaveTranslation(flattenTranslation, currentLang);
        this.translations.set(currentLang, withHook);
        mergedOptions.emitChange && this.setActiveLang(this.getActiveLang());
    };
    /**
     * Sets translation key with given value
     *
     * @example
     *
     * setTranslationKey('key', 'value')
     * setTranslationKey('key.nested', 'value')
     * setTranslationKey('key.nested', 'value', 'en')
     */
    /**
     * Sets translation key with given value
     *
     * \@example
     *
     * setTranslationKey('key', 'value')
     * setTranslationKey('key.nested', 'value')
     * setTranslationKey('key.nested', 'value', 'en')
     * @param {?} key
     * @param {?} value
     * @param {?=} lang
     * @return {?}
     */
    TranslocoService.prototype.setTranslationKey = /**
     * Sets translation key with given value
     *
     * \@example
     *
     * setTranslationKey('key', 'value')
     * setTranslationKey('key.nested', 'value')
     * setTranslationKey('key.nested', 'value', 'en')
     * @param {?} key
     * @param {?} value
     * @param {?=} lang
     * @return {?}
     */
    function (key, value, lang) {
        if (lang === void 0) { lang = this.getActiveLang(); }
        var _a;
        /** @type {?} */
        var withHook = this.interceptor.preSaveTranslationKey(key, value, lang);
        /** @type {?} */
        var newValue = tslib_1.__assign({}, this.getTranslation(lang), (_a = {}, _a[key] = withHook, _a));
        this.setTranslation(newValue, lang);
    };
    /**
     * Sets the fallback lang for the currently active language
     * @param fallbackLang
     */
    /**
     * Sets the fallback lang for the currently active language
     * @param {?} __0
     * @return {?}
     */
    TranslocoService.prototype.setFallbackLangForMissingTranslation = /**
     * Sets the fallback lang for the currently active language
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var fallbackLang = _a.fallbackLang;
        /** @type {?} */
        var lang = Array.isArray(fallbackLang) ? fallbackLang[0] : fallbackLang;
        if (this.useFallbackTranslation(lang) && fallbackLang) {
            this.firstFallbackLang = lang;
        }
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} key
     * @param {?} value
     * @param {?=} params
     * @return {?}
     */
    TranslocoService.prototype._handleMissingKey = /**
     * \@internal
     * @param {?} key
     * @param {?} value
     * @param {?=} params
     * @return {?}
     */
    function (key, value, params) {
        if (this.config.missingHandler.allowEmpty && value === '') {
            return '';
        }
        if (this.useFallbackTranslation() && !this.isResolvedMissingOnce) {
            // We need to set it to true to prevent a loop
            this.isResolvedMissingOnce = true;
            /** @type {?} */
            var fallbackValue = this.translate(key, params, this.firstFallbackLang);
            this.isResolvedMissingOnce = false;
            return fallbackValue;
        }
        return this.missingHandler.handle(key, this.getMissingHandlerData(), params);
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} lang
     * @return {?}
     */
    TranslocoService.prototype._isLangScoped = /**
     * \@internal
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        return this.getAvailableLangsIds().indexOf(lang) === -1;
    };
    /**
     * Checks if a given string is one of the specified available languages.
     * @returns
     * True if the given string is an available language.
     * False if the given string is not an available language.
     */
    /**
     * Checks if a given string is one of the specified available languages.
     * @param {?} lang
     * @return {?}
     * True if the given string is an available language.
     * False if the given string is not an available language.
     */
    TranslocoService.prototype.isLang = /**
     * Checks if a given string is one of the specified available languages.
     * @param {?} lang
     * @return {?}
     * True if the given string is an available language.
     * False if the given string is not an available language.
     */
    function (lang) {
        return this.getAvailableLangsIds().indexOf(lang) !== -1;
    };
    /**
     * @internal
     *
     * We always want to make sure the global lang is loaded
     * before loading the scope since you can access both via the pipe/directive.
     */
    /**
     * \@internal
     *
     * We always want to make sure the global lang is loaded
     * before loading the scope since you can access both via the pipe/directive.
     * @param {?} path
     * @param {?=} inlineLoader
     * @return {?}
     */
    TranslocoService.prototype._loadDependencies = /**
     * \@internal
     *
     * We always want to make sure the global lang is loaded
     * before loading the scope since you can access both via the pipe/directive.
     * @param {?} path
     * @param {?=} inlineLoader
     * @return {?}
     */
    function (path, inlineLoader) {
        /** @type {?} */
        var mainLang = getLangFromScope(path);
        if (this._isLangScoped(path) && !this.isLoadedTranslation(mainLang)) {
            return combineLatest(this.load(mainLang), this.load(path, { inlineLoader: inlineLoader }));
        }
        return this.load(path, { inlineLoader: inlineLoader });
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} langOrScope
     * @return {?}
     */
    TranslocoService.prototype._completeScopeWithLang = /**
     * \@internal
     * @param {?} langOrScope
     * @return {?}
     */
    function (langOrScope) {
        if (this._isLangScoped(langOrScope) && !this.isLang(getLangFromScope(langOrScope))) {
            return langOrScope + "/" + this.getActiveLang();
        }
        return langOrScope;
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} scope
     * @param {?} alias
     * @return {?}
     */
    TranslocoService.prototype._setScopeAlias = /**
     * \@internal
     * @param {?} scope
     * @param {?} alias
     * @return {?}
     */
    function (scope, alias) {
        if (!this.mergedConfig.scopeMapping) {
            this.mergedConfig.scopeMapping = {};
        }
        this.mergedConfig.scopeMapping[scope] = alias;
    };
    /**
     * @return {?}
     */
    TranslocoService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscription.unsubscribe();
    };
    /**
     * @private
     * @param {?} lang
     * @return {?}
     */
    TranslocoService.prototype.isLoadedTranslation = /**
     * @private
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        return size(this.getTranslation(lang));
    };
    /**
     * @private
     * @return {?}
     */
    TranslocoService.prototype.getAvailableLangsIds = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var first = this.getAvailableLangs()[0];
        if (isString(first)) {
            return (/** @type {?} */ (this.getAvailableLangs()));
        }
        return ((/** @type {?} */ (this.getAvailableLangs()))).map((/**
         * @param {?} l
         * @return {?}
         */
        function (l) { return l.id; }));
    };
    /**
     * @private
     * @return {?}
     */
    TranslocoService.prototype.getMissingHandlerData = /**
     * @private
     * @return {?}
     */
    function () {
        return tslib_1.__assign({}, this.config, { activeLang: this.getActiveLang(), availableLangs: this.availableLangs, defaultLang: this.defaultLang });
    };
    /**
     * Use a fallback translation set for missing keys of the primary language
     * This is unrelated to the fallback language (which changes the active language)
     */
    /**
     * Use a fallback translation set for missing keys of the primary language
     * This is unrelated to the fallback language (which changes the active language)
     * @private
     * @param {?=} lang
     * @return {?}
     */
    TranslocoService.prototype.useFallbackTranslation = /**
     * Use a fallback translation set for missing keys of the primary language
     * This is unrelated to the fallback language (which changes the active language)
     * @private
     * @param {?=} lang
     * @return {?}
     */
    function (lang) {
        return this.config.missingHandler.useFallbackTranslation && lang !== this.firstFallbackLang;
    };
    /**
     * @private
     * @param {?} lang
     * @param {?} translation
     * @return {?}
     */
    TranslocoService.prototype.handleSuccess = /**
     * @private
     * @param {?} lang
     * @param {?} translation
     * @return {?}
     */
    function (lang, translation) {
        var _this = this;
        this.setTranslation(translation, lang, { emitChange: false });
        this.events.next({
            wasFailure: !!this.failedLangs.size,
            type: 'translationLoadSuccess',
            payload: getEventPayload(lang)
        });
        this.failedLangs.forEach((/**
         * @param {?} l
         * @return {?}
         */
        function (l) { return _this.cache.delete(l); }));
        this.failedLangs.clear();
    };
    /**
     * @private
     * @param {?} lang
     * @param {?} loadOptions
     * @return {?}
     */
    TranslocoService.prototype.handleFailure = /**
     * @private
     * @param {?} lang
     * @param {?} loadOptions
     * @return {?}
     */
    function (lang, loadOptions) {
        // When starting to load a first choice language, initialize
        // the failed counter and resolve the fallback langs.
        if (isNil(loadOptions.failedCounter)) {
            loadOptions.failedCounter = 0;
            if (!loadOptions.fallbackLangs) {
                loadOptions.fallbackLangs = this.fallbackStrategy.getNextLangs(lang);
            }
        }
        /** @type {?} */
        var splitted = lang.split('/');
        /** @type {?} */
        var fallbacks = loadOptions.fallbackLangs;
        /** @type {?} */
        var nextLang = fallbacks[loadOptions.failedCounter];
        this.failedLangs.add(lang);
        // This handles the case where a loaded fallback language is requested again
        if (this.cache.has(nextLang)) {
            this.handleSuccess(nextLang, this.getTranslation(nextLang));
            return EMPTY;
        }
        /** @type {?} */
        var isFallbackLang = nextLang === splitted[splitted.length - 1];
        if (!nextLang || isFallbackLang) {
            /** @type {?} */
            var msg = "Unable to load translation and all the fallback languages";
            if (splitted.length > 1) {
                msg += ", did you misspelled the scope name?";
            }
            throw new Error(msg);
        }
        /** @type {?} */
        var resolveLang = nextLang;
        // if it's scoped lang
        if (splitted.length > 1) {
            // We need to resolve it to:
            // todos/langNotExists => todos/nextLang
            splitted[splitted.length - 1] = nextLang;
            resolveLang = splitted.join('/');
        }
        loadOptions.failedCounter++;
        this.events.next({
            type: 'translationLoadFailure',
            payload: getEventPayload(lang)
        });
        return this.load(resolveLang, loadOptions);
    };
    /**
     * @private
     * @param {?} scope
     * @return {?}
     */
    TranslocoService.prototype.getMappedScope = /**
     * @private
     * @param {?} scope
     * @return {?}
     */
    function (scope) {
        var _a = this.config.scopeMapping, scopeMapping = _a === void 0 ? {} : _a;
        return scopeMapping[scope] || toCamelCase(scope);
    };
    /**
     * If lang is scope we need to check the following cases:
     * todos/es => in this case we should take `es` as lang
     * todos => in this case we should set the active lang as lang
     */
    /**
     * If lang is scope we need to check the following cases:
     * todos/es => in this case we should take `es` as lang
     * todos => in this case we should set the active lang as lang
     * @private
     * @param {?} lang
     * @return {?}
     */
    TranslocoService.prototype.resolveLangAndScope = /**
     * If lang is scope we need to check the following cases:
     * todos/es => in this case we should take `es` as lang
     * todos => in this case we should set the active lang as lang
     * @private
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        /** @type {?} */
        var resolveLang = lang;
        /** @type {?} */
        var scope;
        if (this._isLangScoped(lang)) {
            // en for example
            /** @type {?} */
            var langFromScope = getLangFromScope(lang);
            // en is lang
            /** @type {?} */
            var hasLang = this.isLang(langFromScope);
            // take en
            resolveLang = hasLang ? langFromScope : this.getActiveLang();
            // find the scope
            scope = this.getMappedScope(hasLang ? getScopeFromLang(lang) : lang);
        }
        return { scope: scope, resolveLang: resolveLang };
    };
    /**
     * @private
     * @param {?} translation
     * @param {?} key
     * @return {?}
     */
    TranslocoService.prototype.getObjectByKey = /**
     * @private
     * @param {?} translation
     * @param {?} key
     * @return {?}
     */
    function (translation, key) {
        /** @type {?} */
        var result = {};
        /** @type {?} */
        var prefix = key + ".";
        for (var currentKey in translation) {
            if (currentKey.startsWith(prefix)) {
                result[currentKey.replace(prefix, '')] = translation[currentKey];
            }
        }
        return result;
    };
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    TranslocoService.prototype.getEntries = /**
     * @private
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return key instanceof Map ? key.entries() : Object.entries(key);
    };
    TranslocoService.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */
    TranslocoService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TRANSLOCO_LOADER,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_TRANSPILER,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_MISSING_HANDLER,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_INTERCEPTOR,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_CONFIG,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_FALLBACK_STRATEGY,] }] }
    ]; };
    /** @nocollapse */ TranslocoService.ngInjectableDef = i0.defineInjectable({ factory: function TranslocoService_Factory() { return new TranslocoService(i0.inject(i1.TRANSLOCO_LOADER, 8), i0.inject(i2.TRANSLOCO_TRANSPILER), i0.inject(i3.TRANSLOCO_MISSING_HANDLER), i0.inject(i4.TRANSLOCO_INTERCEPTOR), i0.inject(i5.TRANSLOCO_CONFIG), i0.inject(i6.TRANSLOCO_FALLBACK_STRATEGY)); }, token: TranslocoService, providedIn: "root" });
    return TranslocoService;
}());
export { TranslocoService };
if (false) {
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.translations;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.cache;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.firstFallbackLang;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.defaultLang;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.mergedConfig;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.availableLangs;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.isResolvedMissingOnce;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.lang;
    /** @type {?} */
    TranslocoService.prototype.langChanges$;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.events;
    /** @type {?} */
    TranslocoService.prototype.events$;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.failedLangs;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.loader;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.parser;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.missingHandler;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.interceptor;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.userConfig;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.fallbackStrategy;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsb2NvLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbmduZWF0L3RyYW5zbG9jby8iLCJzb3VyY2VzIjpbImxpYi90cmFuc2xvY28uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBYSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDeEUsT0FBTyxFQUFFLGVBQWUsRUFBRSxhQUFhLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQWMsRUFBRSxFQUFFLE9BQU8sRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFDcEgsT0FBTyxFQUFFLFVBQVUsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDckYsT0FBTyxFQUFFLGFBQWEsRUFBRSxnQkFBZ0IsRUFBbUIsTUFBTSxvQkFBb0IsQ0FBQztBQUN0RixPQUFPLEVBQUUsb0JBQW9CLEVBQXVCLE1BQU0sd0JBQXdCLENBQUM7QUFjbkYsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLGFBQWEsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDM0csT0FBTyxFQUFFLGFBQWEsRUFBRSxnQkFBZ0IsRUFBbUIsTUFBTSxvQkFBb0IsQ0FBQztBQUN0RixPQUFPLEVBQ0wseUJBQXlCLEVBRzFCLE1BQU0sNkJBQTZCLENBQUM7QUFDckMsT0FBTyxFQUFFLHFCQUFxQixFQUF3QixNQUFNLHlCQUF5QixDQUFDO0FBQ3RGLE9BQU8sRUFBRSwyQkFBMkIsRUFBNkIsTUFBTSwrQkFBK0IsQ0FBQztBQUN2RyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDN0MsT0FBTyxFQUFFLGVBQWUsRUFBRSxnQkFBZ0IsRUFBRSxnQkFBZ0Is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RDs7Ozs7SUFDdEQsaUNBQTJEOzs7OztJQUMzRCw2Q0FBZ0Q7Ozs7O0lBQ2hELHVDQUE0Qjs7Ozs7SUFDNUIsd0NBQXNDOzs7OztJQUN0QywwQ0FBNEM7Ozs7O0lBQzVDLGlEQUFzQzs7Ozs7SUFDdEMsZ0NBQXNDOztJQUN0Qyx3Q0FBaUM7Ozs7O0lBRWpDLGtDQUFnRDs7SUFDaEQsbUNBQXFDOzs7OztJQUVyQyx1Q0FBd0M7Ozs7O0lBR3RDLGtDQUFxRTs7Ozs7SUFDckUsa0NBQWlFOzs7OztJQUNqRSwwQ0FBa0Y7Ozs7O0lBQ2xGLHVDQUF3RTs7Ozs7SUFDeEUsc0NBQTZEOzs7OztJQUM3RCw0Q0FBd0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUsIE9uRGVzdHJveSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgY29tYmluZUxhdGVzdCwgRU1QVFksIGZvcmtKb2luLCBmcm9tLCBPYnNlcnZhYmxlLCBvZiwgU3ViamVjdCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBjYXRjaEVycm9yLCBtYXAsIHJldHJ5LCBzaGFyZVJlcGxheSwgc3dpdGNoTWFwLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBEZWZhdWx0TG9hZGVyLCBUUkFOU0xPQ09fTE9BREVSLCBUcmFuc2xvY29Mb2FkZXIgfSBmcm9tICcuL3RyYW5zbG9jby5sb2FkZXInO1xuaW1wb3J0IHsgVFJBTlNMT0NPX1RSQU5TUElMRVIsIFRyYW5zbG9jb1RyYW5zcGlsZXIgfSBmcm9tICcuL3RyYW5zbG9jby50cmFuc3BpbGVyJztcbmltcG9ydCB7XG4gIEF2YWlsYWJsZUxhbmdzLFxuICBIYXNoTWFwLFxuICBJbmxpbmVMb2FkZXIsXG4gIExvYWRPcHRpb25zLFxuICBQcm92aWRlclNjb3BlLFxuICBTZXRUcmFuc2xhdGlvbk9wdGlvbnMsXG4gIFRyYW5zbGF0ZU9iamVjdFBhcmFtcyxcbiAgVHJhbnNsYXRlUGFyYW1zLFxuICBUcmFuc2xhdGlvbixcbiAgVHJhbnNsb2NvRXZlbnRzLFxuICBUcmFuc2xvY29TY29wZVxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGZsYXR0ZW4sIGlzRW1wdHksIGlzTmlsLCBpc1Njb3BlT2JqZWN0LCBpc1N0cmluZywgc2l6ZSwgdG9DYW1lbENhc2UsIHVuZmxhdHRlbiB9IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQgeyBkZWZhdWx0Q29uZmlnLCBUUkFOU0xPQ09fQ09ORklHLCBUcmFuc2xvY29Db25maWcgfSBmcm9tICcuL3RyYW5zbG9jby5jb25maWcnO1xuaW1wb3J0IHtcbiAgVFJBTlNMT0NPX01JU1NJTkdfSEFORExFUixcbiAgVHJhbnNsb2NvTWlzc2luZ0hhbmRsZXIsXG4gIFRyYW5zbG9jb01pc3NpbmdIYW5kbGVyRGF0YVxufSBmcm9tICcuL3RyYW5zbG9jby1taXNzaW5nLWhhbmRsZXInO1xuaW1wb3J0IHsgVFJBTlNMT0NPX0lOVEVSQ0VQVE9SLCBUcmFuc2xvY29JbnRlcmNlcHRvciB9IGZyb20gJy4vdHJhbnNsb2NvLmludGVyY2VwdG9yJztcbmltcG9ydCB7IFRSQU5TTE9DT19GQUxMQkFDS19TVFJBVEVHWSwgVHJhbnNsb2NvRmFsbGJhY2tTdHJhdGVneSB9IGZyb20gJy4vdHJhbnNsb2NvLWZhbGxiYWNrLXN0cmF0ZWd5JztcbmltcG9ydCB7IG1lcmdlQ29uZmlnIH0gZnJvbSAnLi9tZXJnZS1jb25maWcnO1xuaW1wb3J0IHsgZ2V0RXZlbnRQYXlsb2FkLCBnZXRMYW5nRnJvbVNjb3BlLCBnZXRTY29wZUZyb21MYW5nLCByZXNvbHZlSW5saW5lTG9hZGVyIH0gZnJvbSAnLi9zaGFyZWQnO1xuaW1wb3J0IHsgZ2V0RmFsbGJhY2tzTG9hZGVycyB9IGZyb20gJy4vZ2V0LWZhbGxiYWNrcy1sb2FkZXJzJztcbmltcG9ydCB7IHJlc29sdmVMb2FkZXIgfSBmcm9tICcuL3Jlc29sdmUtbG9hZGVyJztcblxubGV0IHNlcnZpY2U6IFRyYW5zbG9jb1NlcnZpY2U7XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGU8VCA9IGFueT4oa2V5OiBUcmFuc2xhdGVQYXJhbXMsIHBhcmFtczogSGFzaE1hcCA9IHt9LCBsYW5nPzogc3RyaW5nKTogVCB7XG4gIHJldHVybiBzZXJ2aWNlLnRyYW5zbGF0ZShrZXksIHBhcmFtcywgbGFuZyk7XG59XG5cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgVHJhbnNsb2NvU2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgdHJhbnNsYXRpb25zID0gbmV3IE1hcDxzdHJpbmcsIFRyYW5zbGF0aW9uPigpO1xuICBwcml2YXRlIGNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIE9ic2VydmFibGU8VHJhbnNsYXRpb24+PigpO1xuICBwcml2YXRlIGZpcnN0RmFsbGJhY2tMYW5nOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBkZWZhdWx0TGFuZzogc3RyaW5nO1xuICBwcml2YXRlIG1lcmdlZENvbmZpZzogVHJhbnNsb2NvQ29uZmlnO1xuICBwcml2YXRlIGF2YWlsYWJsZUxhbmdzOiBBdmFpbGFibGVMYW5ncyA9IFtdO1xuICBwcml2YXRlIGlzUmVzb2x2ZWRNaXNzaW5nT25jZSA9IGZhbHNlO1xuICBwcml2YXRlIGxhbmc6IEJlaGF2aW9yU3ViamVjdDxzdHJpbmc+O1xuICBsYW5nQ2hhbmdlcyQ6IE9ic2VydmFibGU8c3RyaW5nPjtcblxuICBwcml2YXRlIGV2ZW50cyA9IG5ldyBTdWJqZWN0PFRyYW5zbG9jb0V2ZW50cz4oKTtcbiAgZXZlbnRzJCA9IHRoaXMuZXZlbnRzLmFzT2JzZXJ2YWJsZSgpO1xuXG4gIHByaXZhdGUgZmFpbGVkTGFuZ3MgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KFRSQU5TTE9DT19MT0FERVIpIHByaXZhdGUgbG9hZGVyOiBUcmFuc2xvY29Mb2FkZXIsXG4gICAgQEluamVjdChUUkFOU0xPQ09fVFJBTlNQSUxFUikgcHJpdmF0ZSBwYXJzZXI6IFRyYW5zbG9jb1RyYW5zcGlsZXIsXG4gICAgQEluamVjdChUUkFOU0xPQ09fTUlTU0lOR19IQU5ETEVSKSBwcml2YXRlIG1pc3NpbmdIYW5kbGVyOiBUcmFuc2xvY29NaXNzaW5nSGFuZGxlcixcbiAgICBASW5qZWN0KFRSQU5TTE9DT19JTlRFUkNFUFRPUikgcHJpdmF0ZSBpbnRlcmNlcHRvcjogVHJhbnNsb2NvSW50ZXJjZXB0b3IsXG4gICAgQEluamVjdChUUkFOU0xPQ09fQ09ORklHKSBwcml2YXRlIHVzZXJDb25maWc6IFRyYW5zbG9jb0NvbmZpZyxcbiAgICBASW5qZWN0KFRSQU5TTE9DT19GQUxMQkFDS19TVFJBVEVHWSkgcHJpdmF0ZSBmYWxsYmFja1N0cmF0ZWd5OiBUcmFuc2xvY29GYWxsYmFja1N0cmF0ZWd5XG4gICkge1xuICAgIGlmICghdGhpcy5sb2FkZXIpIHtcbiAgICAgIHRoaXMubG9hZGVyID0gbmV3IERlZmF1bHRMb2FkZXIodGhpcy50cmFuc2xhdGlvbnMpO1xuICAgIH1cbiAgICBzZXJ2aWNlID0gdGhpcztcbiAgICB0aGlzLm1lcmdlZENvbmZpZyA9IG1lcmdlQ29uZmlnKGRlZmF1bHRDb25maWcsIHVzZXJDb25maWcpO1xuXG4gICAgdGhpcy5zZXRBdmFpbGFibGVMYW5ncyh0aGlzLm1lcmdlZENvbmZpZy5hdmFpbGFibGVMYW5ncyk7XG4gICAgdGhpcy5zZXRGYWxsYmFja0xhbmdGb3JNaXNzaW5nVHJhbnNsYXRpb24odGhpcy5tZXJnZWRDb25maWcpO1xuICAgIHRoaXMuc2V0RGVmYXVsdExhbmcodGhpcy5tZXJnZWRDb25maWcuZGVmYXVsdExhbmcpO1xuICAgIHRoaXMubGFuZyA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nPih0aGlzLmdldERlZmF1bHRMYW5nKCkpO1xuICAgIC8vIERvbid0IHVzZSBkaXN0aW5jdFVudGlsQ2hhbmdlZCBhcyB3ZSBuZWVkIHRoZSBhYmlsaXR5IHRvIHVwZGF0ZVxuICAgIC8vIHRoZSB2YWx1ZSB3aGVuIHVzaW5nIHNldFRyYW5zbGF0aW9uIG9yIHNldFRyYW5zbGF0aW9uS2V5c1xuICAgIHRoaXMubGFuZ0NoYW5nZXMkID0gdGhpcy5sYW5nLmFzT2JzZXJ2YWJsZSgpO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiB3ZSBoYXZlIGEgZmFpbHVyZSwgd2Ugd2FudCB0byBkZWZpbmUgdGhlIG5leHQgbGFuZ3VhZ2UgdGhhdCBzdWNjZWVkZWQgYXMgdGhlIGFjdGl2ZVxuICAgICAqL1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5ldmVudHMkLnN1YnNjcmliZShlID0+IHtcbiAgICAgIGlmIChlLnR5cGUgPT09ICd0cmFuc2xhdGlvbkxvYWRTdWNjZXNzJyAmJiBlLndhc0ZhaWx1cmUpIHtcbiAgICAgICAgLy8gSGFuZGxlIHNjb3BlZCBsYW5nXG4gICAgICAgIGNvbnN0IGxhbmcgPSBnZXRMYW5nRnJvbVNjb3BlKGUucGF5bG9hZC5sYW5nKTtcbiAgICAgICAgdGhpcy5zZXRBY3RpdmVMYW5nKGxhbmcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IGNvbmZpZygpOiBUcmFuc2xvY29Db25maWcge1xuICAgIHJldHVybiB0aGlzLm1lcmdlZENvbmZpZztcbiAgfVxuXG4gIGdldERlZmF1bHRMYW5nKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHRMYW5nO1xuICB9XG5cbiAgc2V0RGVmYXVsdExhbmcobGFuZzogc3RyaW5nKSB7XG4gICAgdGhpcy5kZWZhdWx0TGFuZyA9IGxhbmc7XG4gIH1cblxuICBnZXRBY3RpdmVMYW5nKCkge1xuICAgIHJldHVybiB0aGlzLmxhbmcuZ2V0VmFsdWUoKTtcbiAgfVxuXG4gIHNldEFjdGl2ZUxhbmcobGFuZzogc3RyaW5nKSB7XG4gICAgdGhpcy5sYW5nLm5leHQobGFuZyk7XG4gICAgdGhpcy5wYXJzZXIub25MYW5nQ2hhbmdlZCAmJiB0aGlzLnBhcnNlci5vbkxhbmdDaGFuZ2VkKGxhbmcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0QXZhaWxhYmxlTGFuZ3MobGFuZ3M6IEF2YWlsYWJsZUxhbmdzKSB7XG4gICAgdGhpcy5hdmFpbGFibGVMYW5ncyA9IGxhbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGF2YWlsYWJsZSBsYW5ndWFnZXMuXG4gICAqXG4gICAqIEByZXR1cm5zXG4gICAqIEFuIGFycmF5IG9mIHRoZSBhdmFpbGFibGUgbGFuZ3VhZ2VzLiBDYW4gYmUgZWl0aGVyIGEgYHN0cmluZ1tdYCBvciBhIGB7IGlkOiBzdHJpbmc7IGxhYmVsOiBzdHJpbmcgfVtdYFxuICAgKiBkZXBlbmRpbmcgb24gaG93IHRoZSBhdmFpbGFibGUgbGFuZ3VhZ2VzIGFyZSBzZXQgaW4geW91ciBtb2R1bGUuXG4gICAqL1xuICBnZXRBdmFpbGFibGVMYW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5hdmFpbGFibGVMYW5ncztcbiAgfVxuXG4gIGxvYWQocGF0aDogc3RyaW5nLCBvcHRpb25zOiBMb2FkT3B0aW9ucyA9IHt9KTogT2JzZXJ2YWJsZTxUcmFuc2xhdGlvbj4ge1xuICAgIGlmICh0aGlzLmNhY2hlLmhhcyhwYXRoKSA9PT0gZmFsc2UpIHtcbiAgICAgIGxldCBsb2FkVHJhbnNsYXRpb246IE9ic2VydmFibGU8VHJhbnNsYXRpb24gfCB7IHRyYW5zbGF0aW9uOiBUcmFuc2xhdGlvbjsgbGFuZzogc3RyaW5nIH1bXT47XG4gICAgICBjb25zdCBpc1Njb3BlID0gdGhpcy5faXNMYW5nU2NvcGVkKHBhdGgpO1xuICAgICAgY29uc3Qgc2NvcGUgPSBpc1Njb3BlID8gZ2V0U2NvcGVGcm9tTGFuZyhwYXRoKSA6IG51bGw7XG4gICAgICBpZiAodGhpcy51c2VGYWxsYmFja1RyYW5zbGF0aW9uKHBhdGgpKSB7XG4gICAgICAgIC8vIGlmIHRoZSBwYXRoIGlzIHNjb3BlIHRoZSBmYWxsYmFjayBzaG91bGQgYmUgYHNjb3BlL2ZhbGxiYWNrTGFuZ2A7XG4gICAgICAgIGNvbnN0IGZhbGxiYWNrID0gaXNTY29wZSA/IGAke3Njb3BlfS8ke3RoaXMuZmlyc3RGYWxsYmFja0xhbmd9YCA6IHRoaXMuZmlyc3RGYWxsYmFja0xhbmc7XG5cbiAgICAgICAgY29uc3QgbG9hZGVycyA9IGdldEZhbGxiYWNrc0xvYWRlcnMocGF0aCwgZmFsbGJhY2ssIHRoaXMubG9hZGVyLCBvcHRpb25zLmlubGluZUxvYWRlciwgeyBzY29wZSB9KTtcbiAgICAgICAgbG9hZFRyYW5zbGF0aW9uID0gZm9ya0pvaW4obG9hZGVycyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsb2FkZXIgPSByZXNvbHZlTG9hZGVyKHBhdGgsIHRoaXMubG9hZGVyLCBvcHRpb25zLmlubGluZUxvYWRlciwgeyBzY29wZSB9KTtcbiAgICAgICAgbG9hZFRyYW5zbGF0aW9uID0gZnJvbShsb2FkZXIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2FkJCA9IGxvYWRUcmFuc2xhdGlvbi5waXBlKFxuICAgICAgICByZXRyeSh0aGlzLmNvbmZpZy5mYWlsZWRSZXRyaWVzKSxcbiAgICAgICAgdGFwKHRyYW5zbGF0aW9uID0+IHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2xhdGlvbikpIHtcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuaGFuZGxlU3VjY2Vzcyh0LmxhbmcsIHQudHJhbnNsYXRpb24pO1xuICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBmYWxsYmFjayBpbiBjYWNoZSBzbyB3ZSdsbCBub3QgY3JlYXRlIGEgcmVkdW5kYW50IHJlcXVlc3RcbiAgICAgICAgICAgICAgaWYgKHQubGFuZyAhPT0gcGF0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KHQubGFuZywgb2Yoe30pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaGFuZGxlU3VjY2VzcyhwYXRoLCB0cmFuc2xhdGlvbik7XG4gICAgICAgIH0pLFxuICAgICAgICBjYXRjaEVycm9yKCgpID0+IHRoaXMuaGFuZGxlRmFpbHVyZShwYXRoLCBvcHRpb25zKSksXG4gICAgICAgIHNoYXJlUmVwbGF5KDEpXG4gICAgICApO1xuXG4gICAgICB0aGlzLmNhY2hlLnNldChwYXRoLCBsb2FkJCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KHBhdGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGluc3RhbnQgdHJhbnNsYXRlZCB2YWx1ZSBvZiBhIGtleVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB0cmFuc2xhdGU8c3RyaW5nPignaGVsbG8nKVxuICAgKiB0cmFuc2xhdGUoJ2hlbGxvJywgeyB2YWx1ZTogJ3ZhbHVlJyB9KVxuICAgKiB0cmFuc2xhdGU8c3RyaW5nW10+KFsnaGVsbG8nLCAna2V5J10pXG4gICAqIHRyYW5zbGF0ZSgnaGVsbG8nLCB7IH0sICdlbicpXG4gICAqIHRyYW5zbGF0ZSgnc2NvcGUuc29tZUtleScsIHsgfSwgJ2VuJylcbiAgICovXG4gIHRyYW5zbGF0ZTxUID0gYW55PihrZXk6IFRyYW5zbGF0ZVBhcmFtcywgcGFyYW1zOiBIYXNoTWFwID0ge30sIGxhbmcgPSB0aGlzLmdldEFjdGl2ZUxhbmcoKSk6IFQge1xuICAgIGlmICgha2V5KSByZXR1cm4ga2V5IGFzIGFueTtcblxuICAgIGNvbnN0IHsgc2NvcGUsIHJlc29sdmVMYW5nIH0gPSB0aGlzLnJlc29sdmVMYW5nQW5kU2NvcGUobGFuZyk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICByZXR1cm4ga2V5Lm1hcChrID0+IHRoaXMudHJhbnNsYXRlKHNjb3BlID8gYCR7c2NvcGV9LiR7a31gIDogaywgcGFyYW1zLCByZXNvbHZlTGFuZykpIGFzIGFueTtcbiAgICB9XG5cbiAgICBrZXkgPSBzY29wZSA/IGAke3Njb3BlfS4ke2tleX1gIDoga2V5O1xuXG4gICAgY29uc3QgdHJhbnNsYXRpb24gPSB0aGlzLmdldFRyYW5zbGF0aW9uKHJlc29sdmVMYW5nKTtcbiAgICBjb25zdCB2YWx1ZSA9IHRyYW5zbGF0aW9uW2tleV07XG5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFuZGxlTWlzc2luZ0tleShrZXksIHZhbHVlLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhcnNlci50cmFuc3BpbGUodmFsdWUsIHBhcmFtcywgdHJhbnNsYXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHRyYW5zbGF0ZWQgdmFsdWUgb2YgYSBrZXkgYXMgb2JzZXJ2YWJsZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBzZWxlY3RUcmFuc2xhdGU8c3RyaW5nPignaGVsbG8nKS5zdWJzY3JpYmUodmFsdWUgPT4gLi4uKVxuICAgKiBzZWxlY3RUcmFuc2xhdGU8c3RyaW5nPignaGVsbG8nLCB7fSwgJ2VzJykuc3Vic2NyaWJlKHZhbHVlID0+IC4uLilcbiAgICogc2VsZWN0VHJhbnNsYXRlPHN0cmluZz4oJ2hlbGxvJywge30sICd0b2RvcycpLnN1YnNjcmliZSh2YWx1ZSA9PiAuLi4pXG4gICAqIHNlbGVjdFRyYW5zbGF0ZTxzdHJpbmc+KCdoZWxsbycsIHt9LCB7IHNjb3BlOiAndG9kb3MnIH0pLnN1YnNjcmliZSh2YWx1ZSA9PiAuLi4pXG4gICAqXG4gICAqL1xuICBzZWxlY3RUcmFuc2xhdGU8VCA9IGFueT4oXG4gICAga2V5OiBUcmFuc2xhdGVQYXJhbXMsXG4gICAgcGFyYW1zPzogSGFzaE1hcCxcbiAgICBsYW5nPzogc3RyaW5nIHwgVHJhbnNsb2NvU2NvcGUsXG4gICAgX2lzT2JqZWN0ID0gZmFsc2VcbiAgKTogT2JzZXJ2YWJsZTxUPiB7XG4gICAgbGV0IGlubGluZUxvYWRlciA9IG51bGw7XG4gICAgY29uc3QgbG9hZCA9IChsYW5nLCBvcHRpb25zPzogTG9hZE9wdGlvbnMpID0+XG4gICAgICB0aGlzLmxvYWQobGFuZywgb3B0aW9ucykucGlwZShcbiAgICAgICAgbWFwKCgpID0+IChfaXNPYmplY3QgPyB0aGlzLnRyYW5zbGF0ZU9iamVjdChrZXksIHBhcmFtcywgbGFuZykgOiB0aGlzLnRyYW5zbGF0ZShrZXksIHBhcmFtcywgbGFuZykpKVxuICAgICAgKTtcbiAgICBpZiAoaXNOaWwobGFuZykpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhbmdDaGFuZ2VzJC5waXBlKHN3aXRjaE1hcChsYW5nID0+IGxvYWQobGFuZykpKTtcbiAgICB9XG5cbiAgICBpZiAoaXNTY29wZU9iamVjdChsYW5nKSkge1xuICAgICAgLy8gaXQncyBhIHNjb3BlIG9iamVjdC5cbiAgICAgIGNvbnN0IHByb3ZpZGVyU2NvcGUgPSBsYW5nIGFzIFByb3ZpZGVyU2NvcGU7XG4gICAgICBsYW5nID0gcHJvdmlkZXJTY29wZS5zY29wZTtcbiAgICAgIGlubGluZUxvYWRlciA9IHJlc29sdmVJbmxpbmVMb2FkZXIocHJvdmlkZXJTY29wZSwgcHJvdmlkZXJTY29wZS5zY29wZSk7XG4gICAgfVxuXG4gICAgbGFuZyA9IGxhbmcgYXMgc3RyaW5nO1xuICAgIGlmICh0aGlzLmlzTGFuZyhsYW5nKSB8fCB0aGlzLmlzU2NvcGVXaXRoTGFuZyhsYW5nKSkge1xuICAgICAgcmV0dXJuIGxvYWQobGFuZyk7XG4gICAgfVxuICAgIC8vIGl0J3MgYSBzY29wZVxuICAgIGNvbnN0IHNjb3BlID0gbGFuZztcbiAgICByZXR1cm4gdGhpcy5sYW5nQ2hhbmdlcyQucGlwZShzd2l0Y2hNYXAobGFuZyA9PiBsb2FkKGAke3Njb3BlfS8ke2xhbmd9YCwgeyBpbmxpbmVMb2FkZXIgfSkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzY29wZSB3aXRoIGxhbmdcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdG9kb3MvZW4gPT4gdHJ1ZVxuICAgKiB0b2RvcyA9PiBmYWxzZVxuICAgKi9cbiAgcHJpdmF0ZSBpc1Njb3BlV2l0aExhbmcobGFuZzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNMYW5nKGdldExhbmdGcm9tU2NvcGUobGFuZykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zbGF0ZSB0aGUgZ2l2ZW4gcGF0aCB0aGF0IHJldHVybnMgYW4gb2JqZWN0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHNlcnZpY2UudHJhbnNsYXRlT2JqZWN0KCdwYXRoLnRvLm9iamVjdCcsIHsnc3VicGF0aCc6IHsgdmFsdWU6ICdzb21lVmFsdWUnfX0pID0+IHJldHVybnMgdHJhbnNsYXRlZCBvYmplY3RcbiAgICpcbiAgICovXG4gIHRyYW5zbGF0ZU9iamVjdDxUID0gYW55PihrZXk6IHN0cmluZywgcGFyYW1zPzogSGFzaE1hcCwgbGFuZz86IHN0cmluZyk6IFQ7XG4gIHRyYW5zbGF0ZU9iamVjdDxUID0gYW55PihrZXk6IHN0cmluZ1tdLCBwYXJhbXM/OiBIYXNoTWFwLCBsYW5nPzogc3RyaW5nKTogVFtdO1xuICB0cmFuc2xhdGVPYmplY3Q8VCA9IGFueT4oa2V5OiBUcmFuc2xhdGVQYXJhbXMsIHBhcmFtcz86IEhhc2hNYXAsIGxhbmc/OiBzdHJpbmcpOiBUIHwgVFtdO1xuICB0cmFuc2xhdGVPYmplY3Q8VCA9IGFueT4oa2V5OiBIYXNoTWFwIHwgTWFwPHN0cmluZywgSGFzaE1hcD4sIHBhcmFtcz86IG51bGwsIGxhbmc/OiBzdHJpbmcpOiBUW107XG4gIHRyYW5zbGF0ZU9iamVjdDxUID0gYW55PihrZXk6IFRyYW5zbGF0ZU9iamVjdFBhcmFtcywgcGFyYW1zPzogSGFzaE1hcCwgbGFuZyA9IHRoaXMuZ2V0QWN0aXZlTGFuZygpKTogVCB8IFRbXSB7XG4gICAgaWYgKGlzU3RyaW5nKGtleSkgfHwgQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICAgIHJldHVybiBrZXkubWFwKGsgPT4gdGhpcy50cmFuc2xhdGVPYmplY3Qoc2NvcGUgPyBgJHtzY29wZX0uJHtrfWAgOiBrLCBwYXJhbXMsIHJlc29sdmVMYW5nKSkgYXMgYW55O1xuICAgICAgfVxuICAgICAgY29uc3QgeyByZXNvbHZlTGFuZywgc2NvcGUgfSA9IHRoaXMucmVzb2x2ZUxhbmdBbmRTY29wZShsYW5nKTtcblxuICAgICAgY29uc3QgdHJhbnNsYXRpb24gPSB0aGlzLmdldFRyYW5zbGF0aW9uKHJlc29sdmVMYW5nKTtcbiAgICAgIGtleSA9IHNjb3BlID8gYCR7c2NvcGV9LiR7a2V5fWAgOiBrZXk7XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gdW5mbGF0dGVuKHRoaXMuZ2V0T2JqZWN0QnlLZXkodHJhbnNsYXRpb24sIGtleSkpO1xuICAgICAgLyogSWYgYW4gZW1wdHkgb2JqZWN0IHdhcyByZXR1cm5lZCB3ZSB3YW50IHRvIHRyeSBhbmQgdHJhbnNsYXRlIHRoZSBrZXkgYXMgYSBzdHJpbmcgYW5kIG5vdCBhbiBvYmplY3QgKi9cbiAgICAgIHJldHVybiBpc0VtcHR5KHZhbHVlKSA/IHRoaXMudHJhbnNsYXRlKGtleSwgcGFyYW1zLCBsYW5nKSA6IHRoaXMucGFyc2VyLnRyYW5zcGlsZSh2YWx1ZSwgcGFyYW1zLCB0cmFuc2xhdGlvbik7XG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNsYXRpb25zOiBUW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtfa2V5LCBfcGFyYW1zXSBvZiB0aGlzLmdldEVudHJpZXMoa2V5KSkge1xuICAgICAgdHJhbnNsYXRpb25zLnB1c2godGhpcy50cmFuc2xhdGVPYmplY3QoX2tleSwgX3BhcmFtcywgbGFuZykpO1xuICAgIH1cblxuICAgIHJldHVybiB0cmFuc2xhdGlvbnM7XG4gIH1cblxuICBzZWxlY3RUcmFuc2xhdGVPYmplY3Q8VCA9IGFueT4oa2V5OiBzdHJpbmcsIHBhcmFtcz86IEhhc2hNYXAsIGxhbmc/OiBzdHJpbmcpOiBPYnNlcnZhYmxlPFQ+O1xuICBzZWxlY3RUcmFuc2xhdGVPYmplY3Q8VCA9IGFueT4oa2V5OiBzdHJpbmdbXSwgcGFyYW1zPzogSGFzaE1hcCwgbGFuZz86IHN0cmluZyk6IE9ic2VydmFibGU8VFtdPjtcbiAgc2VsZWN0VHJhbnNsYXRlT2JqZWN0PFQgPSBhbnk+KGtleTogSGFzaE1hcCB8IE1hcDxzdHJpbmcsIEhhc2hNYXA+LCBwYXJhbXM/OiBudWxsLCBsYW5nPzogc3RyaW5nKTogT2JzZXJ2YWJsZTxUW10+O1xuICBzZWxlY3RUcmFuc2xhdGVPYmplY3Q8VCA9IGFueT4oXG4gICAga2V5OiBUcmFuc2xhdGVPYmplY3RQYXJhbXMsXG4gICAgcGFyYW1zPzogSGFzaE1hcCxcbiAgICBsYW5nPzogc3RyaW5nXG4gICk6IE9ic2VydmFibGU8VD4gfCBPYnNlcnZhYmxlPFRbXT4ge1xuICAgIGlmIChpc1N0cmluZyhrZXkpIHx8IEFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0VHJhbnNsYXRlPFQ+KGtleSwgcGFyYW1zLCBsYW5nLCB0cnVlKTtcbiAgICB9XG5cbiAgICBjb25zdCBbW2ZpcnN0S2V5LCBmaXJzdFBhcmFtc10sIC4uLnJlc3RdID0gdGhpcy5nZXRFbnRyaWVzKGtleSk7XG5cbiAgICAvKiBJbiBvcmRlciB0byBhdm9pZCBzdWJzY3JpYmluZyBtdWx0aXBsZSB0aW1lcyB0byB0aGUgbG9hZCBsYW5ndWFnZSBldmVudCBieSBjYWxsaW5nIHNlbGVjdFRyYW5zbGF0ZU9iamVjdCBmb3IgZWFjaCBwYWlyLFxuICAgICAqIHdlIGxpc3RlbiB0byB3aGVuIHRoZSBmaXJzdCBrZXkgaGFzIGJlZW4gdHJhbnNsYXRlZCAodGhlIGxhbmd1YWdlIGlzIGxvYWRlZCkgYW5kIHRyYW5zbGF0ZSB0aGUgcmVzdCBzeW5jaHJvbm91c2x5ICovXG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0VHJhbnNsYXRlT2JqZWN0PFQ+KGZpcnN0S2V5LCBmaXJzdFBhcmFtcywgbGFuZykucGlwZShcbiAgICAgIG1hcCh2YWx1ZSA9PiB7XG4gICAgICAgIGNvbnN0IHRyYW5zbGF0aW9ucyA9IFt2YWx1ZV07XG4gICAgICAgIGZvciAoY29uc3QgW19rZXksIF9wYXJhbXNdIG9mIHJlc3QpIHtcbiAgICAgICAgICB0cmFuc2xhdGlvbnMucHVzaCh0aGlzLnRyYW5zbGF0ZU9iamVjdDxUPihfa2V5LCBfcGFyYW1zLCBsYW5nKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJhbnNsYXRpb25zO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gb2JqZWN0IG9mIHRyYW5zbGF0aW9ucyBmb3IgYSBnaXZlbiBsYW5ndWFnZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBnZXRUcmFuc2xhdGlvbigpXG4gICAqIGdldFRyYW5zbGF0aW9uKCdlbicpXG4gICAqIGdldFRyYW5zbGF0aW9uKCdhZG1pbi1wYWdlL2VuJylcbiAgICovXG4gIGdldFRyYW5zbGF0aW9uKCk6IE1hcDxzdHJpbmcsIFRyYW5zbGF0aW9uPjtcbiAgZ2V0VHJhbnNsYXRpb24obGFuZ09yU2NvcGU6IHN0cmluZyk6IFRyYW5zbGF0aW9uO1xuICBnZXRUcmFuc2xhdGlvbihsYW5nT3JTY29wZT86IHN0cmluZyk6IE1hcDxzdHJpbmcsIFRyYW5zbGF0aW9uPiB8IFRyYW5zbGF0aW9uIHtcbiAgICBpZiAobGFuZ09yU2NvcGUpIHtcbiAgICAgIGlmICh0aGlzLmlzTGFuZyhsYW5nT3JTY29wZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRpb25zLmdldChsYW5nT3JTY29wZSkgfHwge307XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc2NvcGUsIGJ1aWxkIHRoZSBzY29wZSB2YWx1ZSBmcm9tIHRoZSB0cmFuc2xhdGlvbiBvYmplY3RcbiAgICAgICAgY29uc3QgeyBzY29wZSwgcmVzb2x2ZUxhbmcgfSA9IHRoaXMucmVzb2x2ZUxhbmdBbmRTY29wZShsYW5nT3JTY29wZSk7XG4gICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uID0gdGhpcy50cmFuc2xhdGlvbnMuZ2V0KHJlc29sdmVMYW5nKSB8fCB7fTtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RCeUtleSh0cmFuc2xhdGlvbiwgc2NvcGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRyYW5zbGF0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIG9iamVjdCBvZiB0cmFuc2xhdGlvbnMgZm9yIGEgZ2l2ZW4gbGFuZ3VhZ2VcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogc2VsZWN0VHJhbnNsYXRpb24oKS5zdWJzY3JpYmUoKSAtIHdpbGwgcmV0dXJuIHRoZSBjdXJyZW50IGxhbmcgdHJhbnNsYXRpb25cbiAgICogc2VsZWN0VHJhbnNsYXRpb24oJ2VzJykuc3Vic2NyaWJlKClcbiAgICogc2VsZWN0VHJhbnNsYXRpb24oJ2FkbWluLXBhZ2UnKS5zdWJzY3JpYmUoKSAtIHdpbGwgcmV0dXJuIHRoZSBjdXJyZW50IGxhbmcgc2NvcGUgdHJhbnNsYXRpb25cbiAgICogc2VsZWN0VHJhbnNsYXRpb24oJ2FkbWluLXBhZ2UvZXMnKS5zdWJzY3JpYmUoKVxuICAgKi9cbiAgc2VsZWN0VHJhbnNsYXRpb24obGFuZz86IHN0cmluZyk6IE9ic2VydmFibGU8VHJhbnNsYXRpb24+IHtcbiAgICBsZXQgbGFuZ3VhZ2UkID0gdGhpcy5sYW5nQ2hhbmdlcyQ7XG4gICAgaWYgKGxhbmcpIHtcbiAgICAgIGNvbnN0IHNjb3BlTGFuZ1NwZWNpZmllZCA9IGdldExhbmdGcm9tU2NvcGUobGFuZykgIT09IGxhbmc7XG4gICAgICBpZiAodGhpcy5pc0xhbmcobGFuZykgfHwgc2NvcGVMYW5nU3BlY2lmaWVkKSB7XG4gICAgICAgIGxhbmd1YWdlJCA9IG9mKGxhbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFuZ3VhZ2UkID0gdGhpcy5sYW5nQ2hhbmdlcyQucGlwZShtYXAoY3VycmVudExhbmcgPT4gYCR7bGFuZ30vJHtjdXJyZW50TGFuZ31gKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhbmd1YWdlJC5waXBlKHN3aXRjaE1hcChsYW5ndWFnZSA9PiB0aGlzLmxvYWQobGFuZ3VhZ2UpLnBpcGUobWFwKCgpID0+IHRoaXMuZ2V0VHJhbnNsYXRpb24obGFuZ3VhZ2UpKSkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIG9yIG1lcmdlIGEgZ2l2ZW4gdHJhbnNsYXRpb24gb2JqZWN0IHRvIGN1cnJlbnQgbGFuZ1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBzZXRUcmFuc2xhdGlvbih7IC4uLiB9KVxuICAgKiBzZXRUcmFuc2xhdGlvbih7IC4uLiB9LCAnZW4nKVxuICAgKiBzZXRUcmFuc2xhdGlvbih7IC4uLiB9LCAnZXMnLCB7IG1lcmdlOiBmYWxzZSB9IClcbiAgICogc2V0VHJhbnNsYXRpb24oeyAuLi4gfSwgJ3RvZG9zL2VuJywgeyBtZXJnZTogZmFsc2UgfSApXG4gICAqL1xuICBzZXRUcmFuc2xhdGlvbih0cmFuc2xhdGlvbjogVHJhbnNsYXRpb24sIGxhbmcgPSB0aGlzLmdldEFjdGl2ZUxhbmcoKSwgb3B0aW9uczogU2V0VHJhbnNsYXRpb25PcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBkZWZhdWx0cyA9IHsgbWVyZ2U6IHRydWUsIGVtaXRDaGFuZ2U6IHRydWUgfTtcbiAgICBjb25zdCBtZXJnZWRPcHRpb25zID0geyAuLi5kZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xuICAgIGNvbnN0IHNjb3BlID0gZ2V0U2NvcGVGcm9tTGFuZyhsYW5nKTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoaXMgaXNuJ3QgYSBzY29wZSB3ZSB1c2UgdGhlIHdob2xlIHRyYW5zbGF0aW9uIGFzIGlzXG4gICAgICogb3RoZXJ3aXNlIHdlIG5lZWQgdG8gZmxhdCB0aGUgc2NvcGUgYW5kIHVzZSBpdFxuICAgICAqL1xuICAgIGxldCBmbGF0dGVuU2NvcGVPclRyYW5zbGF0aW9uID0gdHJhbnNsYXRpb247XG5cbiAgICAvLyBNZXJnZWQgdGhlIHNjb3BlZCBsYW5ndWFnZSBpbnRvIHRoZSBhY3RpdmUgbGFuZ3VhZ2VcbiAgICBpZiAoc2NvcGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0TWFwcGVkU2NvcGUoc2NvcGUpO1xuICAgICAgZmxhdHRlblNjb3BlT3JUcmFuc2xhdGlvbiA9IGZsYXR0ZW4oeyBba2V5XTogdHJhbnNsYXRpb24gfSk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudExhbmcgPSBzY29wZSA/IGdldExhbmdGcm9tU2NvcGUobGFuZykgOiBsYW5nO1xuXG4gICAgY29uc3QgbWVyZ2VkVHJhbnNsYXRpb24gPSB7XG4gICAgICAuLi4obWVyZ2VkT3B0aW9ucy5tZXJnZSAmJiB0aGlzLmdldFRyYW5zbGF0aW9uKGN1cnJlbnRMYW5nKSksXG4gICAgICAuLi5mbGF0dGVuU2NvcGVPclRyYW5zbGF0aW9uXG4gICAgfTtcblxuICAgIGNvbnN0IGZsYXR0ZW5UcmFuc2xhdGlvbiA9IHRoaXMubWVyZ2VkQ29uZmlnLmZsYXR0ZW4uYW90ID8gbWVyZ2VkVHJhbnNsYXRpb24gOiBmbGF0dGVuKG1lcmdlZFRyYW5zbGF0aW9uKTtcbiAgICBjb25zdCB3aXRoSG9vayA9IHRoaXMuaW50ZXJjZXB0b3IucHJlU2F2ZVRyYW5zbGF0aW9uKGZsYXR0ZW5UcmFuc2xhdGlvbiwgY3VycmVudExhbmcpO1xuICAgIHRoaXMudHJhbnNsYXRpb25zLnNldChjdXJyZW50TGFuZywgd2l0aEhvb2spO1xuICAgIG1lcmdlZE9wdGlvbnMuZW1pdENoYW5nZSAmJiB0aGlzLnNldEFjdGl2ZUxhbmcodGhpcy5nZXRBY3RpdmVMYW5nKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdHJhbnNsYXRpb24ga2V5IHdpdGggZ2l2ZW4gdmFsdWVcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogc2V0VHJhbnNsYXRpb25LZXkoJ2tleScsICd2YWx1ZScpXG4gICAqIHNldFRyYW5zbGF0aW9uS2V5KCdrZXkubmVzdGVkJywgJ3ZhbHVlJylcbiAgICogc2V0VHJhbnNsYXRpb25LZXkoJ2tleS5uZXN0ZWQnLCAndmFsdWUnLCAnZW4nKVxuICAgKi9cbiAgc2V0VHJhbnNsYXRpb25LZXkoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcsIGxhbmcgPSB0aGlzLmdldEFjdGl2ZUxhbmcoKSkge1xuICAgIGNvbnN0IHdpdGhIb29rID0gdGhpcy5pbnRlcmNlcHRvci5wcmVTYXZlVHJhbnNsYXRpb25LZXkoa2V5LCB2YWx1ZSwgbGFuZyk7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB7XG4gICAgICAuLi50aGlzLmdldFRyYW5zbGF0aW9uKGxhbmcpLFxuICAgICAgW2tleV06IHdpdGhIb29rXG4gICAgfTtcblxuICAgIHRoaXMuc2V0VHJhbnNsYXRpb24obmV3VmFsdWUsIGxhbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGZhbGxiYWNrIGxhbmcgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIGxhbmd1YWdlXG4gICAqIEBwYXJhbSBmYWxsYmFja0xhbmdcbiAgICovXG4gIHNldEZhbGxiYWNrTGFuZ0Zvck1pc3NpbmdUcmFuc2xhdGlvbih7IGZhbGxiYWNrTGFuZyB9OiBQaWNrPFRyYW5zbG9jb0NvbmZpZywgJ2ZhbGxiYWNrTGFuZyc+KTogdm9pZCB7XG4gICAgY29uc3QgbGFuZyA9IEFycmF5LmlzQXJyYXkoZmFsbGJhY2tMYW5nKSA/IGZhbGxiYWNrTGFuZ1swXSA6IGZhbGxiYWNrTGFuZztcbiAgICBpZiAodGhpcy51c2VGYWxsYmFja1RyYW5zbGF0aW9uKGxhbmcpICYmIGZhbGxiYWNrTGFuZykge1xuICAgICAgdGhpcy5maXJzdEZhbGxiYWNrTGFuZyA9IGxhbmc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2hhbmRsZU1pc3NpbmdLZXkoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnksIHBhcmFtcz86IEhhc2hNYXApIHtcbiAgICBpZiAodGhpcy5jb25maWcubWlzc2luZ0hhbmRsZXIuYWxsb3dFbXB0eSAmJiB2YWx1ZSA9PT0gJycpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy51c2VGYWxsYmFja1RyYW5zbGF0aW9uKCkgJiYgIXRoaXMuaXNSZXNvbHZlZE1pc3NpbmdPbmNlKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIHNldCBpdCB0byB0cnVlIHRvIHByZXZlbnQgYSBsb29wXG4gICAgICB0aGlzLmlzUmVzb2x2ZWRNaXNzaW5nT25jZSA9IHRydWU7XG4gICAgICBjb25zdCBmYWxsYmFja1ZhbHVlID0gdGhpcy50cmFuc2xhdGUoa2V5LCBwYXJhbXMsIHRoaXMuZmlyc3RGYWxsYmFja0xhbmcpO1xuICAgICAgdGhpcy5pc1Jlc29sdmVkTWlzc2luZ09uY2UgPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxsYmFja1ZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm1pc3NpbmdIYW5kbGVyLmhhbmRsZShrZXksIHRoaXMuZ2V0TWlzc2luZ0hhbmRsZXJEYXRhKCksIHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfaXNMYW5nU2NvcGVkKGxhbmc6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmdldEF2YWlsYWJsZUxhbmdzSWRzKCkuaW5kZXhPZihsYW5nKSA9PT0gLTE7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gc3RyaW5nIGlzIG9uZSBvZiB0aGUgc3BlY2lmaWVkIGF2YWlsYWJsZSBsYW5ndWFnZXMuXG4gICAqIEByZXR1cm5zXG4gICAqIFRydWUgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBhbiBhdmFpbGFibGUgbGFuZ3VhZ2UuXG4gICAqIEZhbHNlIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgbm90IGFuIGF2YWlsYWJsZSBsYW5ndWFnZS5cbiAgICovXG4gIGlzTGFuZyhsYW5nOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdmFpbGFibGVMYW5nc0lkcygpLmluZGV4T2YobGFuZykgIT09IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBXZSBhbHdheXMgd2FudCB0byBtYWtlIHN1cmUgdGhlIGdsb2JhbCBsYW5nIGlzIGxvYWRlZFxuICAgKiBiZWZvcmUgbG9hZGluZyB0aGUgc2NvcGUgc2luY2UgeW91IGNhbiBhY2Nlc3MgYm90aCB2aWEgdGhlIHBpcGUvZGlyZWN0aXZlLlxuICAgKi9cbiAgX2xvYWREZXBlbmRlbmNpZXMocGF0aDogc3RyaW5nLCBpbmxpbmVMb2FkZXI/OiBJbmxpbmVMb2FkZXIpOiBPYnNlcnZhYmxlPFRyYW5zbGF0aW9uIHwgVHJhbnNsYXRpb25bXT4ge1xuICAgIGNvbnN0IG1haW5MYW5nID0gZ2V0TGFuZ0Zyb21TY29wZShwYXRoKTtcblxuICAgIGlmICh0aGlzLl9pc0xhbmdTY29wZWQocGF0aCkgJiYgIXRoaXMuaXNMb2FkZWRUcmFuc2xhdGlvbihtYWluTGFuZykpIHtcbiAgICAgIHJldHVybiBjb21iaW5lTGF0ZXN0KHRoaXMubG9hZChtYWluTGFuZyksIHRoaXMubG9hZChwYXRoLCB7IGlubGluZUxvYWRlciB9KSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvYWQocGF0aCwgeyBpbmxpbmVMb2FkZXIgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfY29tcGxldGVTY29wZVdpdGhMYW5nKGxhbmdPclNjb3BlOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5faXNMYW5nU2NvcGVkKGxhbmdPclNjb3BlKSAmJiAhdGhpcy5pc0xhbmcoZ2V0TGFuZ0Zyb21TY29wZShsYW5nT3JTY29wZSkpKSB7XG4gICAgICByZXR1cm4gYCR7bGFuZ09yU2NvcGV9LyR7dGhpcy5nZXRBY3RpdmVMYW5nKCl9YDtcbiAgICB9XG4gICAgcmV0dXJuIGxhbmdPclNjb3BlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3NldFNjb3BlQWxpYXMoc2NvcGU6IHN0cmluZywgYWxpYXM6IHN0cmluZykge1xuICAgIGlmICghdGhpcy5tZXJnZWRDb25maWcuc2NvcGVNYXBwaW5nKSB7XG4gICAgICB0aGlzLm1lcmdlZENvbmZpZy5zY29wZU1hcHBpbmcgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5tZXJnZWRDb25maWcuc2NvcGVNYXBwaW5nW3Njb3BlXSA9IGFsaWFzO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIHByaXZhdGUgaXNMb2FkZWRUcmFuc2xhdGlvbihsYW5nOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gc2l6ZSh0aGlzLmdldFRyYW5zbGF0aW9uKGxhbmcpKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0QXZhaWxhYmxlTGFuZ3NJZHMoKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5nZXRBdmFpbGFibGVMYW5ncygpWzBdO1xuXG4gICAgaWYgKGlzU3RyaW5nKGZpcnN0KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QXZhaWxhYmxlTGFuZ3MoKSBhcyBzdHJpbmdbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKHRoaXMuZ2V0QXZhaWxhYmxlTGFuZ3MoKSBhcyB7IGlkOiBzdHJpbmcgfVtdKS5tYXAobCA9PiBsLmlkKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0TWlzc2luZ0hhbmRsZXJEYXRhKCk6IFRyYW5zbG9jb01pc3NpbmdIYW5kbGVyRGF0YSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgYWN0aXZlTGFuZzogdGhpcy5nZXRBY3RpdmVMYW5nKCksXG4gICAgICBhdmFpbGFibGVMYW5nczogdGhpcy5hdmFpbGFibGVMYW5ncyxcbiAgICAgIGRlZmF1bHRMYW5nOiB0aGlzLmRlZmF1bHRMYW5nXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgYSBmYWxsYmFjayB0cmFuc2xhdGlvbiBzZXQgZm9yIG1pc3Npbmcga2V5cyBvZiB0aGUgcHJpbWFyeSBsYW5ndWFnZVxuICAgKiBUaGlzIGlzIHVucmVsYXRlZCB0byB0aGUgZmFsbGJhY2sgbGFuZ3VhZ2UgKHdoaWNoIGNoYW5nZXMgdGhlIGFjdGl2ZSBsYW5ndWFnZSlcbiAgICovXG4gIHByaXZhdGUgdXNlRmFsbGJhY2tUcmFuc2xhdGlvbihsYW5nPzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLm1pc3NpbmdIYW5kbGVyLnVzZUZhbGxiYWNrVHJhbnNsYXRpb24gJiYgbGFuZyAhPT0gdGhpcy5maXJzdEZhbGxiYWNrTGFuZztcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlU3VjY2VzcyhsYW5nOiBzdHJpbmcsIHRyYW5zbGF0aW9uOiBUcmFuc2xhdGlvbikge1xuICAgIHRoaXMuc2V0VHJhbnNsYXRpb24odHJhbnNsYXRpb24sIGxhbmcsIHsgZW1pdENoYW5nZTogZmFsc2UgfSk7XG4gICAgdGhpcy5ldmVudHMubmV4dCh7XG4gICAgICB3YXNGYWlsdXJlOiAhIXRoaXMuZmFpbGVkTGFuZ3Muc2l6ZSxcbiAgICAgIHR5cGU6ICd0cmFuc2xhdGlvbkxvYWRTdWNjZXNzJyxcbiAgICAgIHBheWxvYWQ6IGdldEV2ZW50UGF5bG9hZChsYW5nKVxuICAgIH0pO1xuICAgIHRoaXMuZmFpbGVkTGFuZ3MuZm9yRWFjaChsID0+IHRoaXMuY2FjaGUuZGVsZXRlKGwpKTtcbiAgICB0aGlzLmZhaWxlZExhbmdzLmNsZWFyKCk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUZhaWx1cmUobGFuZzogc3RyaW5nLCBsb2FkT3B0aW9uczogTG9hZE9wdGlvbnMpIHtcbiAgICAvLyBXaGVuIHN0YXJ0aW5nIHRvIGxvYWQgYSBmaXJzdCBjaG9pY2UgbGFuZ3VhZ2UsIGluaXRpYWxpemVcbiAgICAvLyB0aGUgZmFpbGVkIGNvdW50ZXIgYW5kIHJlc29sdmUgdGhlIGZhbGxiYWNrIGxhbmdzLlxuICAgIGlmIChpc05pbChsb2FkT3B0aW9ucy5mYWlsZWRDb3VudGVyKSkge1xuICAgICAgbG9hZE9wdGlvbnMuZmFpbGVkQ291bnRlciA9IDA7XG5cbiAgICAgIGlmICghbG9hZE9wdGlvbnMuZmFsbGJhY2tMYW5ncykge1xuICAgICAgICBsb2FkT3B0aW9ucy5mYWxsYmFja0xhbmdzID0gdGhpcy5mYWxsYmFja1N0cmF0ZWd5LmdldE5leHRMYW5ncyhsYW5nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzcGxpdHRlZCA9IGxhbmcuc3BsaXQoJy8nKTtcbiAgICBjb25zdCBmYWxsYmFja3MgPSBsb2FkT3B0aW9ucy5mYWxsYmFja0xhbmdzO1xuICAgIGNvbnN0IG5leHRMYW5nID0gZmFsbGJhY2tzW2xvYWRPcHRpb25zLmZhaWxlZENvdW50ZXJdO1xuICAgIHRoaXMuZmFpbGVkTGFuZ3MuYWRkKGxhbmcpO1xuXG4gICAgLy8gVGhpcyBoYW5kbGVzIHRoZSBjYXNlIHdoZXJlIGEgbG9hZGVkIGZhbGxiYWNrIGxhbmd1YWdlIGlzIHJlcXVlc3RlZCBhZ2FpblxuICAgIGlmICh0aGlzLmNhY2hlLmhhcyhuZXh0TGFuZykpIHtcbiAgICAgIHRoaXMuaGFuZGxlU3VjY2VzcyhuZXh0TGFuZywgdGhpcy5nZXRUcmFuc2xhdGlvbihuZXh0TGFuZykpO1xuICAgICAgcmV0dXJuIEVNUFRZO1xuICAgIH1cblxuICAgIGNvbnN0IGlzRmFsbGJhY2tMYW5nID0gbmV4dExhbmcgPT09IHNwbGl0dGVkW3NwbGl0dGVkLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKCFuZXh0TGFuZyB8fCBpc0ZhbGxiYWNrTGFuZykge1xuICAgICAgbGV0IG1zZyA9IGBVbmFibGUgdG8gbG9hZCB0cmFuc2xhdGlvbiBhbmQgYWxsIHRoZSBmYWxsYmFjayBsYW5ndWFnZXNgO1xuICAgICAgaWYgKHNwbGl0dGVkLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbXNnICs9IGAsIGRpZCB5b3UgbWlzc3BlbGxlZCB0aGUgc2NvcGUgbmFtZT9gO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzb2x2ZUxhbmcgPSBuZXh0TGFuZztcbiAgICAvLyBpZiBpdCdzIHNjb3BlZCBsYW5nXG4gICAgaWYgKHNwbGl0dGVkLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gcmVzb2x2ZSBpdCB0bzpcbiAgICAgIC8vIHRvZG9zL2xhbmdOb3RFeGlzdHMgPT4gdG9kb3MvbmV4dExhbmdcbiAgICAgIHNwbGl0dGVkW3NwbGl0dGVkLmxlbmd0aCAtIDFdID0gbmV4dExhbmc7XG4gICAgICByZXNvbHZlTGFuZyA9IHNwbGl0dGVkLmpvaW4oJy8nKTtcbiAgICB9XG5cbiAgICBsb2FkT3B0aW9ucy5mYWlsZWRDb3VudGVyKys7XG4gICAgdGhpcy5ldmVudHMubmV4dCh7XG4gICAgICB0eXBlOiAndHJhbnNsYXRpb25Mb2FkRmFpbHVyZScsXG4gICAgICBwYXlsb2FkOiBnZXRFdmVudFBheWxvYWQobGFuZylcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmxvYWQocmVzb2x2ZUxhbmcsIGxvYWRPcHRpb25zKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0TWFwcGVkU2NvcGUoc2NvcGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgeyBzY29wZU1hcHBpbmcgPSB7fSB9ID0gdGhpcy5jb25maWc7XG4gICAgcmV0dXJuIHNjb3BlTWFwcGluZ1tzY29wZV0gfHwgdG9DYW1lbENhc2Uoc2NvcGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIGxhbmcgaXMgc2NvcGUgd2UgbmVlZCB0byBjaGVjayB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgKiB0b2Rvcy9lcyA9PiBpbiB0aGlzIGNhc2Ugd2Ugc2hvdWxkIHRha2UgYGVzYCBhcyBsYW5nXG4gICAqIHRvZG9zID0+IGluIHRoaXMgY2FzZSB3ZSBzaG91bGQgc2V0IHRoZSBhY3RpdmUgbGFuZyBhcyBsYW5nXG4gICAqL1xuICBwcml2YXRlIHJlc29sdmVMYW5nQW5kU2NvcGUobGFuZzogc3RyaW5nKSB7XG4gICAgbGV0IHJlc29sdmVMYW5nID0gbGFuZztcbiAgICBsZXQgc2NvcGU7XG5cbiAgICBpZiAodGhpcy5faXNMYW5nU2NvcGVkKGxhbmcpKSB7XG4gICAgICAvLyBlbiBmb3IgZXhhbXBsZVxuICAgICAgY29uc3QgbGFuZ0Zyb21TY29wZSA9IGdldExhbmdGcm9tU2NvcGUobGFuZyk7XG4gICAgICAvLyBlbiBpcyBsYW5nXG4gICAgICBjb25zdCBoYXNMYW5nID0gdGhpcy5pc0xhbmcobGFuZ0Zyb21TY29wZSk7XG4gICAgICAvLyB0YWtlIGVuXG4gICAgICByZXNvbHZlTGFuZyA9IGhhc0xhbmcgPyBsYW5nRnJvbVNjb3BlIDogdGhpcy5nZXRBY3RpdmVMYW5nKCk7XG4gICAgICAvLyBmaW5kIHRoZSBzY29wZVxuICAgICAgc2NvcGUgPSB0aGlzLmdldE1hcHBlZFNjb3BlKGhhc0xhbmcgPyBnZXRTY29wZUZyb21MYW5nKGxhbmcpIDogbGFuZyk7XG4gICAgfVxuICAgIHJldHVybiB7IHNjb3BlLCByZXNvbHZlTGFuZyB9O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRPYmplY3RCeUtleSh0cmFuc2xhdGlvbjogVHJhbnNsYXRpb24sIGtleTogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgY29uc3QgcHJlZml4ID0gYCR7a2V5fS5gO1xuXG4gICAgZm9yIChjb25zdCBjdXJyZW50S2V5IGluIHRyYW5zbGF0aW9uKSB7XG4gICAgICBpZiAoY3VycmVudEtleS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgcmVzdWx0W2N1cnJlbnRLZXkucmVwbGFjZShwcmVmaXgsICcnKV0gPSB0cmFuc2xhdGlvbltjdXJyZW50S2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRFbnRyaWVzKGtleTogSGFzaE1hcCB8IE1hcDxzdHJpbmcsIEhhc2hNYXA+KSB7XG4gICAgcmV0dXJuIGtleSBpbnN0YW5jZW9mIE1hcCA/IGtleS5lbnRyaWVzKCkgOiBPYmplY3QuZW50cmllcyhrZXkpO1xuICB9XG59XG4iXX0=