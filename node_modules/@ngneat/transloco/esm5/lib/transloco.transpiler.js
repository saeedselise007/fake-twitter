/**
 * @fileoverview added by tsickle
 * Generated from: lib/transloco.transpiler.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Inject, Injectable, InjectionToken, Injector, Optional } from '@angular/core';
import { getValue, isDefined, isObject, isString, setValue } from './helpers';
import { defaultConfig, TRANSLOCO_CONFIG } from './transloco.config';
/** @type {?} */
export var TRANSLOCO_TRANSPILER = new InjectionToken('TRANSLOCO_TRANSPILER');
/**
 * @record
 */
export function TranslocoTranspiler() { }
if (false) {
    /**
     * @param {?} value
     * @param {?} params
     * @param {?} translation
     * @return {?}
     */
    TranslocoTranspiler.prototype.transpile = function (value, params, translation) { };
    /**
     * @param {?} lang
     * @return {?}
     */
    TranslocoTranspiler.prototype.onLangChanged = function (lang) { };
}
var DefaultTranspiler = /** @class */ (function () {
    function DefaultTranspiler(userConfig) {
        this.interpolationMatcher = resolveMatcher(userConfig);
    }
    /**
     * @param {?} value
     * @param {?=} params
     * @param {?=} translation
     * @return {?}
     */
    DefaultTranspiler.prototype.transpile = /**
     * @param {?} value
     * @param {?=} params
     * @param {?=} translation
     * @return {?}
     */
    function (value, params, translation) {
        var _this = this;
        if (params === void 0) { params = {}; }
        if (isString(value)) {
            return value.replace(this.interpolationMatcher, (/**
             * @param {?} _
             * @param {?} match
             * @return {?}
             */
            function (_, match) {
                match = match.trim();
                if (isDefined(params[match])) {
                    return params[match];
                }
                return isDefined(translation[match]) ? _this.transpile(translation[match], params, translation) : '';
            }));
        }
        else if (params) {
            if (isObject(value)) {
                value = this.handleObject(value, params, translation);
            }
            else if (Array.isArray(value)) {
                value = this.handleArray(value, params, translation);
            }
        }
        return value;
    };
    /**
     *
     * @example
     *
     * const en = {
     *  a: {
     *    b: {
     *      c: "Hello {{ value }}"
     *    }
     *  }
     * }
     *
     * const params =  {
     *  "b.c": { value: "Transloco "}
     * }
     *
     * service.selectTranslate('a', params);
     *
     * // the first param will be the result of `en.a`.
     * // the second param will be `params`.
     * parser.transpile(value, params, {});
     *
     *
     */
    /**
     *
     * \@example
     *
     * const en = {
     *  a: {
     *    b: {
     *      c: "Hello {{ value }}"
     *    }
     *  }
     * }
     *
     * const params =  {
     *  "b.c": { value: "Transloco "}
     * }
     *
     * service.selectTranslate('a', params);
     *
     * // the first param will be the result of `en.a`.
     * // the second param will be `params`.
     * parser.transpile(value, params, {});
     *
     *
     * @protected
     * @param {?} value
     * @param {?=} params
     * @param {?=} translation
     * @return {?}
     */
    DefaultTranspiler.prototype.handleObject = /**
     *
     * \@example
     *
     * const en = {
     *  a: {
     *    b: {
     *      c: "Hello {{ value }}"
     *    }
     *  }
     * }
     *
     * const params =  {
     *  "b.c": { value: "Transloco "}
     * }
     *
     * service.selectTranslate('a', params);
     *
     * // the first param will be the result of `en.a`.
     * // the second param will be `params`.
     * parser.transpile(value, params, {});
     *
     *
     * @protected
     * @param {?} value
     * @param {?=} params
     * @param {?=} translation
     * @return {?}
     */
    function (value, params, translation) {
        var _this = this;
        if (params === void 0) { params = {}; }
        /** @type {?} */
        var result = value;
        Object.keys(params).forEach((/**
         * @param {?} p
         * @return {?}
         */
        function (p) {
            // get the value of "b.c" inside "a" => "Hello {{ value }}"
            /** @type {?} */
            var v = getValue(result, p);
            // get the params of "b.c" => { value: "Transloco" }
            /** @type {?} */
            var getParams = getValue(params, p);
            // transpile the value => "Hello Transloco"
            /** @type {?} */
            var transpiled = _this.transpile(v, getParams, translation);
            // set "b.c" to `transpiled`
            result = setValue(result, p, transpiled);
        }));
        return result;
    };
    /**
     * @protected
     * @param {?} value
     * @param {?=} params
     * @param {?=} translation
     * @return {?}
     */
    DefaultTranspiler.prototype.handleArray = /**
     * @protected
     * @param {?} value
     * @param {?=} params
     * @param {?=} translation
     * @return {?}
     */
    function (value, params, translation) {
        var _this = this;
        if (params === void 0) { params = {}; }
        return value.map((/**
         * @param {?} v
         * @return {?}
         */
        function (v) { return _this.transpile(v, params, translation); }));
    };
    /** @nocollapse */
    DefaultTranspiler.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TRANSLOCO_CONFIG,] }] }
    ]; };
    return DefaultTranspiler;
}());
export { DefaultTranspiler };
if (false) {
    /**
     * @type {?}
     * @protected
     */
    DefaultTranspiler.prototype.interpolationMatcher;
}
/**
 * @param {?=} userConfig
 * @return {?}
 */
function resolveMatcher(userConfig) {
    var _a = tslib_1.__read(userConfig && userConfig.interpolation ? userConfig.interpolation : defaultConfig.interpolation, 2), start = _a[0], end = _a[1];
    return new RegExp(start + "(.*?)" + end, 'g');
}
/**
 * @record
 */
export function TranslocoTranspilerFunction() { }
if (false) {
    /**
     * @param {...?} args
     * @return {?}
     */
    TranslocoTranspilerFunction.prototype.transpile = function (args) { };
}
/**
 * @param {?} argsString
 * @return {?}
 */
export function getFunctionArgs(argsString) {
    /** @type {?} */
    var splitted = argsString ? argsString.split(',') : [];
    /** @type {?} */
    var args = [];
    for (var i = 0; i < splitted.length; i++) {
        /** @type {?} */
        var value = splitted[i].trim();
        while (value[value.length - 1] === '\\') {
            i++;
            value = value.replace('\\', ',') + splitted[i];
        }
        args.push(value);
    }
    return args;
}
var FunctionalTranspiler = /** @class */ (function (_super) {
    tslib_1.__extends(FunctionalTranspiler, _super);
    function FunctionalTranspiler(injector) {
        var _this = _super.call(this) || this;
        _this.injector = injector;
        return _this;
    }
    /**
     * @param {?} value
     * @param {?=} params
     * @param {?=} translation
     * @return {?}
     */
    FunctionalTranspiler.prototype.transpile = /**
     * @param {?} value
     * @param {?=} params
     * @param {?=} translation
     * @return {?}
     */
    function (value, params, translation) {
        var _this = this;
        if (params === void 0) { params = {}; }
        /** @type {?} */
        var transpiled = value;
        if (isString(value)) {
            transpiled = value.replace(/\[\[\s*(\w+)\((.*)\)\s*]]/g, (/**
             * @param {?} match
             * @param {?} functionName
             * @param {?} args
             * @return {?}
             */
            function (match, functionName, args) {
                try {
                    /** @type {?} */
                    var func = _this.injector.get(functionName);
                    return func.transpile.apply(func, tslib_1.__spread(getFunctionArgs(args)));
                }
                catch (e) {
                    /** @type {?} */
                    var message = "There is an error in: '" + value + "'. \n                          Check that the you used the right syntax in your translation and that the implementation of " + functionName + " is correct.";
                    if (e.message.includes('NullInjectorError')) {
                        message = "You are using the '" + functionName + "' function in your translation but no provider was found!";
                    }
                    throw new Error(message);
                }
            }));
        }
        return _super.prototype.transpile.call(this, transpiled, params, translation);
    };
    FunctionalTranspiler.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    FunctionalTranspiler.ctorParameters = function () { return [
        { type: Injector }
    ]; };
    return FunctionalTranspiler;
}(DefaultTranspiler));
export { FunctionalTranspiler };
if (false) {
    /**
     * @type {?}
     * @private
     */
    FunctionalTranspiler.prototype.injector;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsb2NvLnRyYW5zcGlsZXIuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbmduZWF0L3RyYW5zbG9jby8iLCJzb3VyY2VzIjpbImxpYi90cmFuc2xvY28udHJhbnNwaWxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxjQUFjLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUV2RixPQUFPLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUM5RSxPQUFPLEVBQUUsYUFBYSxFQUFFLGdCQUFnQixFQUFtQixNQUFNLG9CQUFvQixDQUFDOztBQUV0RixNQUFNLEtBQU8sb0JBQW9CLEdBQUcsSUFBSSxjQUFjLENBQUMsc0JBQXNCLENBQUM7Ozs7QUFFOUUseUNBSUM7Ozs7Ozs7O0lBSEMsb0ZBQWtFOzs7OztJQUVsRSxrRUFBbUM7O0FBR3JDO0lBR0UsMkJBQWtELFVBQTRCO1FBQzVFLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDekQsQ0FBQzs7Ozs7OztJQUVELHFDQUFTOzs7Ozs7SUFBVCxVQUFVLEtBQVUsRUFBRSxNQUFvQixFQUFFLFdBQXdCO1FBQXBFLGlCQW1CQztRQW5CcUIsdUJBQUEsRUFBQSxXQUFvQjtRQUN4QyxJQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNuQixPQUFPLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLG9CQUFvQjs7Ozs7WUFBRSxVQUFDLENBQUMsRUFBRSxLQUFLO2dCQUN2RCxLQUFLLEdBQUcsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUNyQixJQUFJLFNBQVMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtvQkFDNUIsT0FBTyxNQUFNLENBQUMsS0FBSyxD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TyxHQUFHLHdCQUFzQixZQUFZLDhEQUEyRCxDQUFDO3FCQUN6RztvQkFDRCxNQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2lCQUMxQjtZQUNILENBQUMsRUFBQyxDQUFDO1NBQ0o7UUFFRCxPQUFPLGlCQUFNLFNBQVMsWUFBQyxVQUFVLEVBQUUsTUFBTSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQzFELENBQUM7O2dCQTFCRixVQUFVOzs7O2dCQWxIa0MsUUFBUTs7SUE2SXJELDJCQUFDO0NBQUEsQUEzQkQsQ0FDMEMsaUJBQWlCLEdBMEIxRDtTQTFCWSxvQkFBb0I7Ozs7OztJQUNuQix3Q0FBMEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBJbmplY3RvciwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEhhc2hNYXAsIFRyYW5zbGF0aW9uIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRWYWx1ZSwgaXNEZWZpbmVkLCBpc09iamVjdCwgaXNTdHJpbmcsIHNldFZhbHVlIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7IGRlZmF1bHRDb25maWcsIFRSQU5TTE9DT19DT05GSUcsIFRyYW5zbG9jb0NvbmZpZyB9IGZyb20gJy4vdHJhbnNsb2NvLmNvbmZpZyc7XG5cbmV4cG9ydCBjb25zdCBUUkFOU0xPQ09fVFJBTlNQSUxFUiA9IG5ldyBJbmplY3Rpb25Ub2tlbignVFJBTlNMT0NPX1RSQU5TUElMRVInKTtcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2xvY29UcmFuc3BpbGVyIHtcbiAgdHJhbnNwaWxlKHZhbHVlOiBhbnksIHBhcmFtczogSGFzaE1hcCwgdHJhbnNsYXRpb246IEhhc2hNYXApOiBhbnk7XG5cbiAgb25MYW5nQ2hhbmdlZD8obGFuZzogc3RyaW5nKTogdm9pZDtcbn1cblxuZXhwb3J0IGNsYXNzIERlZmF1bHRUcmFuc3BpbGVyIGltcGxlbWVudHMgVHJhbnNsb2NvVHJhbnNwaWxlciB7XG4gIHByb3RlY3RlZCBpbnRlcnBvbGF0aW9uTWF0Y2hlcjogUmVnRXhwO1xuXG4gIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIEBJbmplY3QoVFJBTlNMT0NPX0NPTkZJRykgdXNlckNvbmZpZz86IFRyYW5zbG9jb0NvbmZpZykge1xuICAgIHRoaXMuaW50ZXJwb2xhdGlvbk1hdGNoZXIgPSByZXNvbHZlTWF0Y2hlcih1c2VyQ29uZmlnKTtcbiAgfVxuXG4gIHRyYW5zcGlsZSh2YWx1ZTogYW55LCBwYXJhbXM6IEhhc2hNYXAgPSB7fSwgdHJhbnNsYXRpb246IFRyYW5zbGF0aW9uKTogYW55IHtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSh0aGlzLmludGVycG9sYXRpb25NYXRjaGVyLCAoXywgbWF0Y2gpID0+IHtcbiAgICAgICAgbWF0Y2ggPSBtYXRjaC50cmltKCk7XG4gICAgICAgIGlmIChpc0RlZmluZWQocGFyYW1zW21hdGNoXSkpIHtcbiAgICAgICAgICByZXR1cm4gcGFyYW1zW21hdGNoXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc0RlZmluZWQodHJhbnNsYXRpb25bbWF0Y2hdKSA/IHRoaXMudHJhbnNwaWxlKHRyYW5zbGF0aW9uW21hdGNoXSwgcGFyYW1zLCB0cmFuc2xhdGlvbikgOiAnJztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zKSB7XG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5oYW5kbGVPYmplY3QodmFsdWUsIHBhcmFtcywgdHJhbnNsYXRpb24pO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuaGFuZGxlQXJyYXkodmFsdWUsIHBhcmFtcywgdHJhbnNsYXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBjb25zdCBlbiA9IHtcbiAgICogIGE6IHtcbiAgICogICAgYjoge1xuICAgKiAgICAgIGM6IFwiSGVsbG8ge3sgdmFsdWUgfX1cIlxuICAgKiAgICB9XG4gICAqICB9XG4gICAqIH1cbiAgICpcbiAgICogY29uc3QgcGFyYW1zID0gIHtcbiAgICogIFwiYi5jXCI6IHsgdmFsdWU6IFwiVHJhbnNsb2NvIFwifVxuICAgKiB9XG4gICAqXG4gICAqIHNlcnZpY2Uuc2VsZWN0VHJhbnNsYXRlKCdhJywgcGFyYW1zKTtcbiAgICpcbiAgICogLy8gdGhlIGZpcnN0IHBhcmFtIHdpbGwgYmUgdGhlIHJlc3VsdCBvZiBgZW4uYWAuXG4gICAqIC8vIHRoZSBzZWNvbmQgcGFyYW0gd2lsbCBiZSBgcGFyYW1zYC5cbiAgICogcGFyc2VyLnRyYW5zcGlsZSh2YWx1ZSwgcGFyYW1zLCB7fSk7XG4gICAqXG4gICAqXG4gICAqL1xuICBwcm90ZWN0ZWQgaGFuZGxlT2JqZWN0KHZhbHVlOiBhbnksIHBhcmFtczogSGFzaE1hcCA9IHt9LCB0cmFuc2xhdGlvbjogVHJhbnNsYXRpb24pIHtcbiAgICBsZXQgcmVzdWx0ID0gdmFsdWU7XG5cbiAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2gocCA9PiB7XG4gICAgICAvLyBnZXQgdGhlIHZhbHVlIG9mIFwiYi5jXCIgaW5zaWRlIFwiYVwiID0+IFwiSGVsbG8ge3sgdmFsdWUgfX1cIlxuICAgICAgY29uc3QgdiA9IGdldFZhbHVlKHJlc3VsdCwgcCk7XG4gICAgICAvLyBnZXQgdGhlIHBhcmFtcyBvZiBcImIuY1wiID0+IHsgdmFsdWU6IFwiVHJhbnNsb2NvXCIgfVxuICAgICAgY29uc3QgZ2V0UGFyYW1zID0gZ2V0VmFsdWUocGFyYW1zLCBwKTtcblxuICAgICAgLy8gdHJhbnNwaWxlIHRoZSB2YWx1ZSA9PiBcIkhlbGxvIFRyYW5zbG9jb1wiXG4gICAgICBjb25zdCB0cmFuc3BpbGVkID0gdGhpcy50cmFuc3BpbGUodiwgZ2V0UGFyYW1zLCB0cmFuc2xhdGlvbik7XG5cbiAgICAgIC8vIHNldCBcImIuY1wiIHRvIGB0cmFuc3BpbGVkYFxuICAgICAgcmVzdWx0ID0gc2V0VmFsdWUocmVzdWx0LCBwLCB0cmFuc3BpbGVkKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwcm90ZWN0ZWQgaGFuZGxlQXJyYXkodmFsdWU6IHN0cmluZ1tdLCBwYXJhbXM6IEhhc2hNYXAgPSB7fSwgdHJhbnNsYXRpb246IFRyYW5zbGF0aW9uKSB7XG4gICAgcmV0dXJuIHZhbHVlLm1hcCh2ID0+IHRoaXMudHJhbnNwaWxlKHYsIHBhcmFtcywgdHJhbnNsYXRpb24pKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlTWF0Y2hlcih1c2VyQ29uZmlnPzogVHJhbnNsb2NvQ29uZmlnKTogUmVnRXhwIHtcbiAgY29uc3QgW3N0YXJ0LCBlbmRdID0gdXNlckNvbmZpZyAmJiB1c2VyQ29uZmlnLmludGVycG9sYXRpb24gPyB1c2VyQ29uZmlnLmludGVycG9sYXRpb24gOiBkZWZhdWx0Q29uZmlnLmludGVycG9sYXRpb247XG5cbiAgcmV0dXJuIG5ldyBSZWdFeHAoYCR7c3RhcnR9KC4qPykke2VuZH1gLCAnZycpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zbG9jb1RyYW5zcGlsZXJGdW5jdGlvbiB7XG4gIHRyYW5zcGlsZSguLi5hcmdzOiBzdHJpbmdbXSk6IGFueTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZ1bmN0aW9uQXJncyhhcmdzU3RyaW5nOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIGNvbnN0IHNwbGl0dGVkID0gYXJnc1N0cmluZyA/IGFyZ3NTdHJpbmcuc3BsaXQoJywnKSA6IFtdO1xuICBjb25zdCBhcmdzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3BsaXR0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgdmFsdWUgPSBzcGxpdHRlZFtpXS50cmltKCk7XG4gICAgd2hpbGUgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnXFxcXCcpIHtcbiAgICAgIGkrKztcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgnXFxcXCcsICcsJykgKyBzcGxpdHRlZFtpXTtcbiAgICB9XG4gICAgYXJncy5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBhcmdzO1xufVxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25hbFRyYW5zcGlsZXIgZXh0ZW5kcyBEZWZhdWx0VHJhbnNwaWxlciBpbXBsZW1lbnRzIFRyYW5zbG9jb1RyYW5zcGlsZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICB0cmFuc3BpbGUodmFsdWU6IGFueSwgcGFyYW1zOiBIYXNoTWFwID0ge30sIHRyYW5zbGF0aW9uOiBUcmFuc2xhdGlvbik6IGFueSB7XG4gICAgbGV0IHRyYW5zcGlsZWQgPSB2YWx1ZTtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICB0cmFuc3BpbGVkID0gdmFsdWUucmVwbGFjZSgvXFxbXFxbXFxzKihcXHcrKVxcKCguKilcXClcXHMqXV0vZywgKG1hdGNoOiBzdHJpbmcsIGZ1bmN0aW9uTmFtZTogc3RyaW5nLCBhcmdzOiBzdHJpbmcpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBmdW5jOiBUcmFuc2xvY29UcmFuc3BpbGVyRnVuY3Rpb24gPSB0aGlzLmluamVjdG9yLmdldChmdW5jdGlvbk5hbWUpO1xuXG4gICAgICAgICAgcmV0dXJuIGZ1bmMudHJhbnNwaWxlKC4uLmdldEZ1bmN0aW9uQXJncyhhcmdzKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBsZXQgbWVzc2FnZSA9IGBUaGVyZSBpcyBhbiBlcnJvciBpbjogJyR7dmFsdWV9Jy4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgIENoZWNrIHRoYXQgdGhlIHlvdSB1c2VkIHRoZSByaWdodCBzeW50YXggaW4geW91ciB0cmFuc2xhdGlvbiBhbmQgdGhhdCB0aGUgaW1wbGVtZW50YXRpb24gb2YgJHtmdW5jdGlvbk5hbWV9IGlzIGNvcnJlY3QuYDtcbiAgICAgICAgICBpZiAoZS5tZXNzYWdlLmluY2x1ZGVzKCdOdWxsSW5qZWN0b3JFcnJvcicpKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gYFlvdSBhcmUgdXNpbmcgdGhlICcke2Z1bmN0aW9uTmFtZX0nIGZ1bmN0aW9uIGluIHlvdXIgdHJhbnNsYXRpb24gYnV0IG5vIHByb3ZpZGVyIHdhcyBmb3VuZCFgO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci50cmFuc3BpbGUodHJhbnNwaWxlZCwgcGFyYW1zLCB0cmFuc2xhdGlvbik7XG4gIH1cbn1cbiJdfQ==